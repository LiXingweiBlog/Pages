<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>区块链简单实现之p2p网络多节点同步</title>
    <link href="/Pages/2021/05/21/2021-05-21-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B9%8Bp2p%E7%BD%91%E7%BB%9C%E5%A4%9A%E8%8A%82%E7%82%B9%E5%90%8C%E6%AD%A5/"/>
    <url>/Pages/2021/05/21/2021-05-21-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B9%8Bp2p%E7%BD%91%E7%BB%9C%E5%A4%9A%E8%8A%82%E7%82%B9%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>承接上文：<a href="https://blog.csdn.net/qq_43289711/article/details/116082281">区块链的简单实现</a>，我们已经实现了一个简单的区块链数据结构。<br>现状：区块存放在数组中，程序重启就是一条新链，并且也只有单节点，没有引入多节点。<br>目标：将区块保存为文件，实现多节点之间的同步。</p><h2 id="将区块保存为json文件"><a href="#将区块保存为json文件" class="headerlink" title="将区块保存为json文件"></a>将区块保存为json文件</h2><p>之前的类<code>BlockChain</code>的<code>creatBlock</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">creatBlock</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> lastBlock=<span class="hljs-built_in">this</span>.getLastBlock();<br>        <span class="hljs-keyword">var</span> newIndex=lastBlock.index+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">var</span> newTime=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()/<span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">var</span> newPreHash=lastBlock.hash;<br>        <span class="hljs-keyword">var</span> newhash=Block.caHash(newIndex,newPreHash,newTime,data.toString());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.blocks[<span class="hljs-built_in">this</span>.blocks.length]= <span class="hljs-keyword">new</span> Block.Block(<br>            newIndex, newPreHash, newTime, data, newhash<br>        );<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看的出来，是直接保存在数组<code>blocks</code>中，我们稍作改进：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">creatBlock</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> lastBlock=<span class="hljs-built_in">this</span>.getLastBlock();<br>        <span class="hljs-keyword">var</span> newIndex=lastBlock.index+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">var</span> newTime=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()/<span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">var</span> newPreHash=lastBlock.hash;<br>        <span class="hljs-keyword">var</span> creator= <span class="hljs-built_in">this</span>.path;<span class="hljs-comment">//简单的用路径来代替用户，creator是Block新增的一个属性</span><br>        <span class="hljs-keyword">var</span> newhash=Block.caHash(newIndex,newPreHash,newTime,data.toString(),creator);<br>        <span class="hljs-keyword">var</span> newblock= <span class="hljs-keyword">new</span> Block.Block(<br>            newIndex, newPreHash, newTime, data, newhash,creator<br>        );<br>        fs.writeFile(<span class="hljs-string">&quot;./blcs/&quot;</span>+<span class="hljs-built_in">this</span>.path+<span class="hljs-string">&quot;/block&quot;</span>+<span class="hljs-built_in">this</span>.head.nums+<span class="hljs-string">&quot;.json&quot;</span>,<span class="hljs-built_in">JSON</span>.stringify(newblock,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;\t&quot;</span>),<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span> (err!=<span class="hljs-literal">null</span>)<br>                <span class="hljs-built_in">console</span>.log(err);<br>        &#125;);<br>        <br><span class="hljs-comment">//此处注释掉的为后续增加的代码，此时可暂不阅读</span><br>       <span class="hljs-comment">// this.head.nums++;</span><br>       <span class="hljs-comment">// this.head.existsHash.push(newhash);</span><br>      <span class="hljs-comment">//  if (!this.head.creators.includes(newblock.creator))</span><br>       <span class="hljs-comment">//     this.head.creators.push(newblock.creator);</span><br>            <br>     <span class="hljs-comment">//   fs.writeFile(&quot;./blcs/&quot;+this.path+&quot;/head.json&quot;,JSON.stringify(this.head,&quot;&quot;,&quot;\t&quot;),function (err)&#123;</span><br>     <span class="hljs-comment">//       if (err!=null)</span><br>     <span class="hljs-comment">//           console.log(err);</span><br>     <span class="hljs-comment">//   &#125;);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.blocks[<span class="hljs-built_in">this</span>.blocks.length]=newblock;<br>    &#125;<br></code></pre></td></tr></table></figure><p>增加了一步写文件的操作，将<code>newblock</code>对象写入<code>./blcs/path/blockx.json</code>，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210521152125197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="区块被写入为json文件"></p><p>如此，便能解决区块的存储问题。</p><h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><p>一个节点可以简单理解为一个用户，他们各有一条链，理想情况下，他们链上的内容不应起冲突并且应该能够实时同步，但我们都知道，一个分布式系统想要实时同步几乎是不可能的，我们需要一种合理的同步机制，尽量减少错误的发生。</p><p>p2p网络能帮助我们实现各节点的同步与通信，我们希望在每个节点生成区块或者接收区块时能广播通知网络中的其他节点也接收区块。</p><h2 id="不确定性"><a href="#不确定性" class="headerlink" title="不确定性"></a>不确定性</h2><p>但是有一个摆在面前的问题：</p><ul><li>我们无法得知网络中各节点的信息。</li></ul><p>解决这个问题的一个思路是，建立一个中心化的服务器来存放各个节点的信息，但是显然这样不合我们的思路。<br>还有一个思路，就是在每个区块中保存一些有关节点的信息。</p><h2 id="区块里保存节点信息"><a href="#区块里保存节点信息" class="headerlink" title="区块里保存节点信息"></a>区块里保存节点信息</h2><p>我采取的办法是，在每个区块增加一个<code>creator</code>的属性，用来保存产生它的那个节点的信息，便于我们能在网络中找到这个节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Block</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">index, previousHash, timestamp, data, hash, creator</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.index = index;<br>        <span class="hljs-built_in">this</span>.previousHash = previousHash;<br>        <span class="hljs-built_in">this</span>.timestamp = timestamp;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.hash = hash.toString();<br>        <span class="hljs-built_in">this</span>.creator = creator;<span class="hljs-comment">//保存产生它的节点的信息</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&#123;\nindex:&quot;</span>+<span class="hljs-built_in">this</span>.index+<span class="hljs-string">&quot;,\npreviousHash:&#x27;&quot;</span>+<span class="hljs-built_in">this</span>.previousHash+<span class="hljs-string">&quot;&#x27;,\ntimestamp:&quot;</span>+<span class="hljs-built_in">this</span>.timestamp+<span class="hljs-string">&quot;,\ndata:&#x27;&quot;</span>+<span class="hljs-built_in">this</span>.data+<span class="hljs-string">&quot;&#x27;,\nhash:&#x27;&quot;</span>+<span class="hljs-built_in">this</span>.hash+<span class="hljs-string">&quot;&#x27;,\ncreator:&#x27;&quot;</span>+<span class="hljs-built_in">this</span>.creator+ <span class="hljs-string">&quot;&#x27;\n&#125;\n&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我本地运行的各个节点是运行在不同的端口号，我就可以通过在creator属性里保存端口号从而能找到节点，放在更大的网络里，我们可以保存产生它的节点的ip地址。</p><p>这样在其他节点接收到区块后，就可以从自己已有的区块里和其他节点联系上了，那么就可以实现广播。</p><h2 id="并未向所有节点广播"><a href="#并未向所有节点广播" class="headerlink" title="并未向所有节点广播"></a>并未向所有节点广播</h2><p>其实很容易看出来，上面的思路不是真的广播，因为只有那些产生过区块并广播出去的节点才可能收到来自其他节点的广播。</p><p>那么那些没有产生过区块的节点呢？很多节点都是产生交易单然后经由矿工打包成区块，那么他们就不能收到广播，这是不合理的。不过这已经不在我们目前讨论范围了，因为我们区块的数据并没有什么实际含义，我们可以简单的认为节点就是各个矿机，随便拿着数据然后在做工作量证明然后签名发给其他节点。</p><h2 id="简单模拟"><a href="#简单模拟" class="headerlink" title="简单模拟"></a>简单模拟</h2><p>我本地模拟多个节点采取的办法是，将程序运行在多个端口，让它们在各端口间同步数据，其实也具备p2p网络的特性了：</p><ul><li>不知道有哪些端口号有区块链程序在运行</li><li>不知道运行的区块链程序是否已经停止运行</li><li>各个端口之间可以互相发送http请求和响应</li></ul><p>所以我给各个端口上的区块链程序之间同步信息的解决方法如下：</p><p>各个节点都会从自己的链中整理出各个区块的<code>hash</code>和 <code>creator</code>，然后遵循以下策略：</p><ol><li>接受一个区块后，要向自己知道的节点广播。</li><li>新生成一个区块后，要向自己知道的节点广播。</li><li>在接收到一个区块时判断自己是否已经接受过该区块的hash值，如果接受过就不再接受也不广播，否则接受并广播。</li><li>在接收到区块时都应当先作验证，验证区块是否有效。</li><li>接收到一个区块时，发现该区块的序号远大于自己序号最大的区块，应当从区块发出节点拉取前面的区块。</li></ol><p>上述规则看似能解决问题，但是存在一个重大的问题：<br>在网络起步阶段时，各个节点都还没有接收过其他节点的区块，那么是无法从0到有的。<br>这时候需要我们给定一个默认的联系节点，只要网络运行起来了，哪怕这个默认节点停用了也无所谓。</p><h2 id="广播的代码："><a href="#广播的代码：" class="headerlink" title="广播的代码："></a>广播的代码：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">broadcastBlock</span>(<span class="hljs-params">block</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> blockString=<span class="hljs-built_in">JSON</span>.stringify(block,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;\t&quot;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;broadcast&quot;</span>);<br>    <span class="hljs-keyword">var</span> options = &#123;<br>        hostname: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        port: <span class="hljs-number">2343</span>,<span class="hljs-comment">//默认的联系节点的端口</span><br>        path: <span class="hljs-string">&#x27;/receive&#x27;</span>,<br>        method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        headers: &#123;<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>            <span class="hljs-string">&#x27;Content-Length&#x27;</span>: Buffer.byteLength(blockString)<br>        &#125;<br>    &#125;;<br><br><br>    <span class="hljs-keyword">var</span> ports=BlockChain.head.creators;<span class="hljs-comment">//获取链中所有区块的creator，然后逐一发送</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;ports.length;i++)&#123;<br>        options.port=ports[i];<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">var</span> req=http.request(options,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>                res.on(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;已经发送至：&quot;</span>+ports[i]);<br>                &#125;);<br>                res.on(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;没什么&quot;</span>);<br>                    <span class="hljs-built_in">console</span>.log(chunk);<br>                &#125;)<br>                res.on(<span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>                    <span class="hljs-built_in">console</span>.log(port[i]+<span class="hljs-string">&quot;数据传输出错&quot;</span>);<br>                &#125;)<br>            &#125;);<br>            req.on(<span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>                <span class="hljs-built_in">console</span>.log((port[i])+<span class="hljs-string">&quot;未上线，未向其发送2&quot;</span>);<br>                req.end();<br>                <span class="hljs-comment">//console.log(err);</span><br>            &#125;)<br>            req.write(blockString);<br>            req.end();<br>            <span class="hljs-comment">//console.log(&quot;已经发送至：&quot;+ports[i]);</span><br>        &#125;<span class="hljs-keyword">catch</span> (err) &#123;<br>            <span class="hljs-built_in">console</span>.log(ports[i]+<span class="hljs-string">&quot;发送失败&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h2><p>上次运行保存的区块信息：<br><img src="https://img-blog.csdnimg.cn/20210521204656885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="启动前"></p><p>分别运行程序在2343,2344,2345三个端口上，然后从2343端口抓取的区块：</p><p><img src="https://img-blog.csdnimg.cn/20210521205013823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="2343端口的节点的区块信息"><br>在2343端口生成一个区块：<br><img src="https://img-blog.csdnimg.cn/20210521205328711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="输入数据段"><br><img src="https://img-blog.csdnimg.cn/20210521205432747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="生成区块成功"></p><p>到2344和2345端口查看是否同步过来了：<br>其实之间看自己文件有没有多就知道了，下图中明显同步了。<br><img src="https://img-blog.csdnimg.cn/20210521205631644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="完整的代码："><a href="#完整的代码：" class="headerlink" title="完整的代码："></a>完整的代码：</h1><p>你可以从仓库里获取完整代码：</p><p>github: <a href="https://github.com/Lixingwei0623/ablockchain">https://github.com/Lixingwei0623/ablockchain</a>.<br>gitee: <a href="https://gitee.com/li-xingwei/simple-block-chain">https://gitee.com/li-xingwei/simple-block-chain</a>.</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>区块链</category>
      
      <category>p2p</category>
      
    </categories>
    
    
    <tags>
      
      <tag>p2p</tag>
      
      <tag>node.js</tag>
      
      <tag>json</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何写规范的文档</title>
    <link href="/Pages/2021/04/30/2021-04-30-markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/Pages/2021/04/30/2021-04-30-markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>换行是不要钱的，只要不是连续的文本都可以在中间加一个或多个换行，无论输入多少空行，最终显示的效果也是没有空行的。</li><li>本质都是文字，只是会使用一些符号来放在这一行文本的开头，来设置这一行文本的格式。</li><li>注意标记符号和文本内容要有一个距离，一般是一个空格或一个换行。</li><li>所有的图片都是根据链接地址寻找的，所以这张图片要先上传到网络，并得到他的链接。</li></ul><h1 id="先写标题"><a href="#先写标题" class="headerlink" title="先写标题"></a>先写标题</h1><p>标题有等级，等级随<code>#</code>的个数增加而降低，最高级的一个<code>#</code>，比如我的文档写的内容如下：<br>(注意<code>#</code>和标题文本之间要留一个空格)</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 一级标题1</span><br><span class="hljs-meta">## 二级标题1</span><br><span class="hljs-meta">### 三级标题1</span><br><span class="hljs-meta">## 二级标题2</span><br><span class="hljs-meta"># 一级标题2</span><br></code></pre></td></tr></table></figure><p>那么它显示的效果如下：</p><blockquote><h1 id="一级标题1"><a href="#一级标题1" class="headerlink" title="一级标题1"></a>一级标题1</h1><h2 id="二级标题1"><a href="#二级标题1" class="headerlink" title="二级标题1"></a>二级标题1</h2><h3 id="三级标题1"><a href="#三级标题1" class="headerlink" title="三级标题1"></a>三级标题1</h3><h2 id="二级标题2"><a href="#二级标题2" class="headerlink" title="二级标题2"></a>二级标题2</h2><h1 id="一级标题2"><a href="#一级标题2" class="headerlink" title="一级标题2"></a>一级标题2</h1></blockquote><p>我们应该在文章里比较均匀合理的设置小标题，方便理清文章的层次结构。</p><h1 id="写普通文本"><a href="#写普通文本" class="headerlink" title="写普通文本"></a>写普通文本</h1><p>普通文本还是占文章的大部分，也就是没有用任何特殊符号来标记修饰的文本。</p><h1 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h1><p>在众多的普通文本中，总有些文本是我们希望他们不一样，比如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">普通样式：电话号码119是火警电话<br>行内代码：电话号码<span class="hljs-code">``119``</span>是火警电话<br>强调样式：电话号码<span class="hljs-strong">*119*</span>是火警电话<br>加粗样式：电话号码<span class="hljs-strong">**119**</span>是火警电话<br></code></pre></td></tr></table></figure><p>它们对应的效果：</p><blockquote><p>普通样式：电话号码119是火警电话<br>行内代码：电话号码<code>119</code>是火警电话<br>强调样式：电话号码<em>119</em>是火警电话<br>加粗样式：电话号码<strong>119</strong>是火警电话</p></blockquote><h1 id="段落样式"><a href="#段落样式" class="headerlink" title="段落样式"></a>段落样式</h1><p>一般常用的有引用格式和代码片段</p><blockquote><p>这里是引用格式<br>看起来很清爽<br>仿佛置身局外一样<br>这是在每一行的开头添加一个<code>&gt;</code>符号得到的</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">这里是代码片格式<br>看起来很专业<br>是专门放代码片段的地方<br>这是在段落的开头和结尾都用```来标记<br></code></pre></td></tr></table></figure><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>图片都是根据链接来得到的，便于移植。</p><h2 id="固定大小形式："><a href="#固定大小形式：" class="headerlink" title="固定大小形式："></a>固定大小形式：</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[图片描述信息]</span>(link)<br>!<span class="hljs-selector-attr">[CSDN编辑工具]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//img-blog.csdnimg.cn/20210501015405692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70)</span><br></code></pre></td></tr></table></figure><p>下面这张图就是上面第二行的图片效果：<br><img src="https://img-blog.csdnimg.cn/20210501015405692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="CSDN编辑工具"></p><h2 id="可变大小形式"><a href="#可变大小形式" class="headerlink" title="可变大小形式"></a>可变大小形式</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;mpx;&quot;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;npx;&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;link&quot;</span>/&gt;<br>&lt;img <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;500px;&quot;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;250px;&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;CSDN编辑工具&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://img-blog.csdnimg.cn/20210501015405692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>在第一行中，<code>m</code> <code>n</code> <code>message</code> <code>link</code>依次是宽，高，图片信息，图片链接<br>第二行是一个示例，它的效果如下：<br><img width="500px;" height="250px;" alt="CSDN编辑工具" src="https://img-blog.csdnimg.cn/20210501015405692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70"/></p><h1 id="其他一些结构"><a href="#其他一些结构" class="headerlink" title="其他一些结构"></a>其他一些结构</h1><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span> 第一行<br><span class="hljs-bullet">+</span> 第二行<br><span class="hljs-bullet">+</span> 第三行<br><br><span class="hljs-bullet">1.</span> 第一行<br><span class="hljs-bullet">2.</span> 第二行<br><span class="hljs-bullet">3.</span> 第三行<br></code></pre></td></tr></table></figure><p>注意<code>+</code>以及<code>1.</code> <code>2.</code> <code>3.</code>与它们后面的文本有一个空格<br>他们的演示效果为：</p><ul><li>第一行</li><li>第二行</li><li>第三行</li></ul><ol><li>第一行</li><li>第二行</li><li>第三行</li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>掌握以上基础，写一个简洁大方的markdown文档已经不成问题，另外平时需要其他更多样式的时候要大胆的百度搜索，因为上面仅仅只是一小部分。而且markdown是兼容html的，所以样式很多很多。</p><h1 id="额外一点"><a href="#额外一点" class="headerlink" title="额外一点"></a>额外一点</h1><p>针对我们自己上传的markdown文档，会在开头加上这篇文章的属性，便于对文章管理，它们犹如文章的身份证，格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><br><span class="hljs-attr">title:</span> <span class="hljs-string">如何写规范的文档</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-string">/2/2</span> <span class="hljs-number">12</span><span class="hljs-string">:00:00</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">兴伟</span><br><span class="hljs-attr">categories:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">规范</span><br><span class="hljs-attr">tags:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">教程</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">兴伟撰写</span><br><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>title</code>是标题，写这个文章的标题</li><li><code>date</code>是时间，按格式写时间</li><li><code>author</code>是作者，随便写</li><li><code>categories</code>是分类名，随便写，自己想给它分到什么类就什么类，可以分多个类，但建议只指定一个类</li><li><code>tags</code>是标签，随便写，与分类作用类似，但是更偏向内容，一般是几个重要的关键字。</li></ul><p>注意：<code>:</code>和<code>-</code>与文本之间存在一个空格，不是直接相连，并且<code>-</code>距离行首是一个<code>tab</code>键的距离。</p>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>撰写文章规范</title>
    <link href="/Pages/2021/04/29/2021-04-29-%E6%96%87%E6%A1%A3%E4%B8%8A%E4%BC%A0/"/>
    <url>/Pages/2021/04/29/2021-04-29-%E6%96%87%E6%A1%A3%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<p>我的小宝贝，这是为你写的一个整理文章的平台，下面由我这篇文章来告诉你怎么撰写文章的规范吧。</p><h2 id="文章规范"><a href="#文章规范" class="headerlink" title="文章规范"></a>文章规范</h2><h3 id="markdown文本语法"><a href="#markdown文本语法" class="headerlink" title="markdown文本语法"></a>markdown文本语法</h3><p>这个语法最常用于写博客文章，里面很适合融入代码，<br>但是它不单单可以写博客，它可以用来写记录生活的文章，<br>可以抒发感情，可以插入图片，可以插入视频，<br>可以像编辑一个公众号文章一样随心所欲，<br>不过初次写这样的文章，可能会碰很多坑。<br>我们可以进入<a href="https://www.csdn.net/">CSDN</a> 然后在它的在线编辑工具里学习这中文法。</p><p><img src="https://img-blog.csdnimg.cn/20210430200204915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="CSDN编辑工具截图"></p><h3 id="将写好的marhdown-md-文档上传到此站点"><a href="#将写好的marhdown-md-文档上传到此站点" class="headerlink" title="将写好的marhdown(.md)文档上传到此站点"></a>将写好的marhdown(.md)文档上传到此站点</h3><p>由于上传文章需要配置hexo环境和github仓库，这些我在自己电脑上做了，要是帮你配置好，你可能也也不会用。<br>所以要上传任何东西，我可以代理奥。<br>但是你要按照markdown语法规范来奥，不然文章的样式不能保证。<br>（如果有样式和图片的话，尽量先到CSDN的编辑器里写好）</p><h3 id="文章的属性"><a href="#文章的属性" class="headerlink" title="文章的属性"></a>文章的属性</h3><p>每篇文章都可以有属性奥，这些属性都是可以自定义的。<br>一般有以下属性：标题，时间，作者，分类，标签<br>这些属性要写在文章的开头：<br><img src="https://img-blog.csdnimg.cn/20210430201558479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="md文档的文章属性"><br>正如上面图片所示，我写的这个规范文章的属性，就在开头的—和—之间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">---<br>title: 撰写文章规范<br>date: <span class="hljs-number">2020</span>/<span class="hljs-number">2</span>/<span class="hljs-number">2</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>author: 兴伟<br>categories:<br>    - 规范<br>tags:<br>    - HEXO<br>    - 教程<br>    - 兴伟撰写<br>---<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HEXO</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双系统之重装linux系统并保持原软件和配置不变(亲测好用推荐)</title>
    <link href="/Pages/2021/04/25/2021-04-26-linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E5%A4%AA%E5%B0%8F%E9%9C%80%E8%A6%81%E9%87%8D%E8%A3%85%E5%B9%B6%E4%BF%9D%E7%95%99%E5%8E%9F%E6%9C%89%E6%95%B0%E6%8D%AE%E5%92%8C%E7%8E%AF%E5%A2%83/"/>
    <url>/Pages/2021/04/25/2021-04-26-linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E5%A4%AA%E5%B0%8F%E9%9C%80%E8%A6%81%E9%87%8D%E8%A3%85%E5%B9%B6%E4%BF%9D%E7%95%99%E5%8E%9F%E6%9C%89%E6%95%B0%E6%8D%AE%E5%92%8C%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>我第一次装ubuntu时，只是想学会使用linux操作系统，因此装的双系统，并且只给ubuntu分派了小小的20G硬盘，以至于后面根本不够用，中间又从windows压缩10G挂载到根目录的一个目录下，但后面还是不够用，而且自动挂载的空间用起来不方便。而且现在已经习惯在linux下编程了，但是平时办公又用习惯了windows，而且windows下的office一系列功能确实要强大许多。于是决定继续双系统，在某个周末鼓起勇气要重装ubuntu系统，给它多分配一些空间。<br>重装ubuntu并完整恢复原来的环境和软件，如编程环境、IDE、其他应用如Chrome、办公文件。来吧，兄弟，我有重装十多遍的教训要告诉你，每个步骤都带图，要是看不懂，你打我。</p></blockquote><p>面临以下问题：</p><ul><li>怎么备份ubuntu系统里的数据？</li><li>怎么完全卸载ubuntu？</li><li>怎么重装？</li><li>怎么恢复环境和数据？</li></ul><h1 id="开始操作前"><a href="#开始操作前" class="headerlink" title="开始操作前"></a>开始操作前</h1><blockquote><p>我有很多IDE诸如idea,pycharm,webstore等，还有jdk、python、node的环境，还有装得wine+QQ,wine+钉钉，还有chrome等等，还有一些服务的配置如ssh服务等等，我希望我这些东西都能在重装系统后能够一如往常的使用。</p></blockquote><p>我们的思路是先把数据备份，然后卸载ubuntu重装后再把数据恢复，下面马上操作起来。</p><h1 id="一、数据备份"><a href="#一、数据备份" class="headerlink" title="一、数据备份"></a>一、数据备份</h1><p>准备一个U盘，用tar命令打包归档，保留各文件之间的权限信息。</p><h2 id="1-切换root并来到u盘挂载的目录"><a href="#1-切换root并来到u盘挂载的目录" class="headerlink" title="1. 切换root并来到u盘挂载的目录"></a>1. 切换root并来到u盘挂载的目录</h2><p><img src="https://img-blog.csdnimg.cn/20210426191449627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="root用户进入u盘目录"></p><h2 id="2-tar命令备份目录"><a href="#2-tar命令备份目录" class="headerlink" title="2. tar命令备份目录"></a>2. tar命令备份目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar cvpzf usr.tgz /usr<br></code></pre></td></tr></table></figure><p><strong>上面的命令的效果是把<code>/usr</code>打包为<code>usr.tgz</code>并存放在当前的目录下。<br>除了<code>/usr</code>还有<code>/opt</code> <code>/home</code>，这三个必须打包备份，然后还有自己定义的目录，比如我有个自定义的目录<code>/new</code>，我也打包好。</strong></p><blockquote><p><code>/etc</code>可以打包也可以不打包，如果你希望新装的系统继续保持现在的各个用户名和密码，就也打包。至于其他目录不用打包了，比如 <code>/boot </code> <code>/bin </code> <code>cdrom </code> <code>dev </code> <code>media </code> <code>mnt </code>等，打包了也是没用的，因为他们要么在新系统无法使用，要么就算效果和信息系统一样，比如 <code> /bin</code>里面都是命令，新系统并不缺命令， 再如<code>/media </code>是根本派不上用场的。（下图中我还打包了 <code> /lib</code>，其实不用，而且后面解压这个数据到新系统会引起驱动不适配导致系统崩溃）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2021042619281177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="备份好的压缩包"></p><h1 id="二、卸载ubuntu"><a href="#二、卸载ubuntu" class="headerlink" title="二、卸载ubuntu"></a>二、卸载ubuntu</h1><h2 id="3-制作U盘启动盘"><a href="#3-制作U盘启动盘" class="headerlink" title="3. 制作U盘启动盘"></a>3. 制作U盘启动盘</h2><p>关键是找好iso镜像文件，然后用刻录工具来制作启动盘。</p><blockquote><p>ubuntu自带启动盘制作器，windows下也可以制作，可以参考我以前的文章<br>《如何安装windows和linux双操作系统？》: <a href="https://blog.csdn.net/qq_43289711/article/details/110312956">https://blog.csdn.net/qq_43289711/article/details/110312956</a>.</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426193916982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="ubuntu自带启动盘制作器"></p><h2 id="4-关机进入windows来卸载干净ubuntu"><a href="#4-关机进入windows来卸载干净ubuntu" class="headerlink" title="4. 关机进入windows来卸载干净ubuntu"></a>4. 关机进入windows来卸载干净ubuntu</h2><ul><li>(1).首先进入磁盘管理，然后选择ubuntu所在的分区直接右击然后删除卷使得其成为未分配状态。<img src="https://img-blog.csdnimg.cn/2021042502463313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="windows磁盘管理"></li></ul><ul><li>(2).然后win+x，选择（windows PowerShell（管理员））然后按照下面命令操作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">diskpart<span class="hljs-comment"># 进入系统dispart组件</span><br>list disk<span class="hljs-comment"># 查看系统所有磁盘，并找到window系统所安装的磁盘,（会出现列表，比如你有两个硬盘，０和１）</span><br>select disk $<span class="hljs-comment"># 选择磁盘 $ 指window所安装的磁盘（列表，磁盘后的数字）(例如select disk 0)</span><br>list partition<span class="hljs-comment"># 找到类型为系统的分区（列表会显示）</span><br>select partition $<span class="hljs-comment"># $为类型为系统的分区　（例如select partition 0）</span><br>assign letter=p<span class="hljs-comment"># 将分区分配到磁盘P中，p是直接写得，不和c，d，e等盘冲突就可以了</span><br><span class="hljs-built_in">exit</span> <span class="hljs-comment"># 退出diskpart</span><br></code></pre></td></tr></table></figure>再搜索记事本，以管理员身份打开，然后如图操作删除ubuntu：</li></ul><p><img src="https://img-blog.csdnimg.cn/20210426200228748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="删除开机是ubuntu选择项"></p><p>然后在回到管理员命令行，移除p盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">diskpart <span class="hljs-comment"># 再次进入到diskpart</span><br>select  disk $<span class="hljs-comment"># $是之前选择的盘符，如果记不住了，用list disk查看</span><br>selectpartition$<span class="hljs-comment"># $是之前选择的分区，如果记不住了，用list partition查看</span><br>remove letter=p <span class="hljs-comment"># 删除P盘，</span><br><span class="hljs-built_in">exit</span><span class="hljs-comment"># 退出</span><br></code></pre></td></tr></table></figure><blockquote><p>至此，ubuntu无论是磁盘上的数据，还是开机时的条目，都被清理掉。</p></blockquote><h1 id="三、安装ubuntu"><a href="#三、安装ubuntu" class="headerlink" title="三、安装ubuntu"></a>三、安装ubuntu</h1><h2 id="5-插U盘重启，进入BIOS选择U盘启动盘。"><a href="#5-插U盘重启，进入BIOS选择U盘启动盘。" class="headerlink" title="5. 插U盘重启，进入BIOS选择U盘启动盘。"></a>5. 插U盘重启，进入BIOS选择U盘启动盘。</h2><blockquote><p>依旧可以参考我以前的文章<br>《如何安装windows和linux双操作系统？》: <a href="https://blog.csdn.net/qq_43289711/article/details/110312956">https://blog.csdn.net/qq_43289711/article/details/110312956</a>.</p></blockquote><p>每个不同的机器要按不同的键来进入BIOS，我的华硕是esc，所以我在开机时多按几次，<br>依次进入下面两个画面：</p><p><img src="https://img-blog.csdnimg.cn/20210426201341363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="select boot device"></p><p><img src="https://img-blog.csdnimg.cn/20210426201418990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="GRUB"></p><p>选择Install Ubuntu就开始安装。</p><h2 id="6-进入ubuntu安装向导"><a href="#6-进入ubuntu安装向导" class="headerlink" title="6. 进入ubuntu安装向导"></a>6. 进入ubuntu安装向导</h2><p>这里基本都很简单，语言选中文简体，正常安装，在最后的磁盘分区上选择与windows共存，然后开始安装把分区设置写入硬盘。不用多久就可以安装完成。<br>！！！注意!!注意!!!：在设置你第一个用户名的时候，一定要设置成你上一台机器第一个设置的用户，也就是你的sudo用户，如果你不这样的话，那么在后面，请不要导入<code>/etc</code>，否则覆盖用户后，系统会找不到当前登录的用户，之后关机重启会有各种问题（很有可能循环登录无法进入图形界面），并且家目录也需要自己手动的复原了。</p><h1 id="四、恢复数据"><a href="#四、恢复数据" class="headerlink" title="四、恢复数据"></a>四、恢复数据</h1><h2 id="7-切换root并进入保存数据的U盘的数据所在目录"><a href="#7-切换root并进入保存数据的U盘的数据所在目录" class="headerlink" title="7. 切换root并进入保存数据的U盘的数据所在目录"></a>7. 切换root并进入保存数据的U盘的数据所在目录</h2><blockquote><p>有同学可能就疑惑了，不知到root用户的密码，因为自己只设置了当前的sudo用户的密码。那么我来教你改root的密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;sudo -i<br>&gt;可以输入当前用户密码然后就切换root用户了，然后再：<br>&gt;passwd root<br>&gt;设置新密码<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426203836281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="root用户进入数据备份目录"></p><h2 id="8-恢复数据"><a href="#8-恢复数据" class="headerlink" title="8.恢复数据"></a>8.恢复数据</h2><p>使用<code>tar</code>命令来恢复数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xvpfz usr.tgz -C /<br></code></pre></td></tr></table></figure><p>这条命令的意思是把<code>usr.tgz</code>解压到<code>/</code>下，并且新系统的<code>/usr</code>就会被替代掉。<br>对应自己备份的数据来操作所有的包。</p><p>==注意！！！！注意！！！！注意<br>不是任何原来系统的包都可以随意替代新系统的，除了本文讲到的<code>/usr</code> <code>/home</code> <code>opt</code>和新系统没有的自定义目录外，其他包都是要特殊处理的，否则可能系统关机后就等着重装吧。==</p><p>我们的配置信息都在系统级配置都在<code>/etc</code>，我们在将其来替代新系统的<code>/etc</code>时注意：</p><ul><li>开始说好的，当前第一次注册的用户名要和以前的一样</li><li>把新系统的<code>/etc/fstab</code>文件先换个地方保存起来，等到整个<code>/etc</code>被替换后，再把它替换回来，因为它里面保存的是当前系统挂载的硬盘的物理首地址，这个地址每次重装都不一样，如果被修改了，新系统在重启时直接找不到自己的硬盘，你就可以再次重装了。<img src="https://img-blog.csdnimg.cn/20210426205432759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="fatab文件内容"></li></ul><h2 id="大功告成，检查有无异常"><a href="#大功告成，检查有无异常" class="headerlink" title="大功告成，检查有无异常"></a>大功告成，检查有无异常</h2><p>一般都每什么问题，我自己现在空间从之前的20G变成现在的74G</p><p>  <img src="https://img-blog.csdnimg.cn/20210426205808373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="在磁盘扩充"></p><p>然后，我的软件也都可以用，数据也都在，和重装前感觉一样</p><p><img src="https://img-blog.csdnimg.cn/20210426210114959.png" alt="应用软件正常"></p><p>再看编程环境：</p><p><img src="https://img-blog.csdnimg.cn/20210426210238560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="编程环境测试"></p><p>都还在，还好还好。</p>]]></content>
    
    
    <categories>
      
      <category>双系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>卸载ubuntu</tag>
      
      <tag>tar命令</tag>
      
      <tag>数据备份</tag>
      
      <tag>安装ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu根目录空间太小的数据备份并恢复完整重装【双系统重装必看！！】</title>
    <link href="/Pages/2021/04/25/2021-04-25-ubuntu%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E5%A4%AA%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%B9%B6%E6%81%A2%E5%A4%8D%E5%AE%8C%E6%95%B4%E9%87%8D%E8%A3%85/"/>
    <url>/Pages/2021/04/25/2021-04-25-ubuntu%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E5%A4%AA%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%B9%B6%E6%81%A2%E5%A4%8D%E5%AE%8C%E6%95%B4%E9%87%8D%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="本文适用解决什么问题？"><a href="#本文适用解决什么问题？" class="headerlink" title="本文适用解决什么问题？"></a>本文适用解决什么问题？</h1><p>如果你装了双系统，现在要卸载linux重装，且原linux系统里的软件和配置要完整保留，那么你找对了。当然你也可以借鉴其中某个步骤来解决你某个问题，比如怎么用systemback给当前系统生成iso文件、iso文件大于4G该如何生成、完整备份整个系统为iso文件、完整卸载linux、制作系统启动盘、安装双系统等等操作。</p><p>作者遇到问题描述：<br>之前装了双系统，只给ubuntu分了20G，虽然后面又压缩卷10G挂载，但是挂载的不方便，所以打算把ubuntu重装多分配一些硬盘，但是ubuntu用了小半年了，里面很多软件工具和环境，一一部署很麻烦，所以想把当前的ubuntu做成一个iso镜像文件刻录到U盘，然后卸载ubuntu，再重新压缩卷，多压一些空间，再把U盘来重装ubuntu，以达到原数据不变，只扩大空间的目的。</p><h1 id="ubuntu系统完整备份"><a href="#ubuntu系统完整备份" class="headerlink" title="ubuntu系统完整备份"></a>ubuntu系统完整备份</h1><p>开始也看过用tar命令来备份自己的整个根目录到U盘，但是tar命令每次打包到4G大小左右就不动了，报错说太大了。<br>所以准备把自己的ubuntu做成iso文件，直接重装。</p><h1 id="systemback的使用"><a href="#systemback的使用" class="headerlink" title="systemback的使用"></a>systemback的使用</h1><h2 id="安装systemback"><a href="#安装systemback" class="headerlink" title="安装systemback"></a>安装systemback</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span>ppa:nemh/systemback<br>sudo apt update<br>sudo apt install<span class="hljs-keyword"> system</span>back<br></code></pre></td></tr></table></figure><p>一般就用以上命令安装就好了，但是如果你出错了，说找不到源或者不支持，那么先运行这条命令删除自己系统版本的PPA:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo<span class="hljs-built_in"> add-apt-repository </span>--remove ppa:nemh/systemback<br></code></pre></td></tr></table></figure><p>然后再替代成其他版本的PPA:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> add-apt-repository <span class="hljs-string">&quot;deb http://ppa.launchpad.net/nemh/systemback/ubuntu xenial main&quot;</span><br><span class="hljs-attribute">sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys <span class="hljs-number">382003</span>C<span class="hljs-number">2</span>C<span class="hljs-number">8</span>B<span class="hljs-number">7</span>B<span class="hljs-number">4</span>AB<span class="hljs-number">813</span>E<span class="hljs-number">915</span>B<span class="hljs-number">14</span>E<span class="hljs-number">4942973</span>C<span class="hljs-number">62</span>A<span class="hljs-number">1</span>B<br></code></pre></td></tr></table></figure><p>然后再行安装systemback</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt update<br>sudo apt <span class="hljs-keyword">install</span> systemback<br></code></pre></td></tr></table></figure><h2 id="使用systemback"><a href="#使用systemback" class="headerlink" title="使用systemback"></a>使用systemback</h2><p>在应用列表找到并运行，输入自己系统的用户名和密码进入</p><p>单击<code>Live System Create</code>按钮，然后为ISO文件命名，可以选择包含用户数据文件，单击新建按钮以创建实时系统，系统的每个文件都会被纳入，未选中用户数据，则家目录的数据不会。</p><p>然后<code>工作目录</code>要选择够大的空间，并且是linux文件系统格式的空间，也就是ext4，相信各位自己的根目录下已经找不到能再容纳一遍自己所有数据的空间了，所以我是选择的U盘的挂载目录，但是U盘是不能直接用的，除非你的U盘是专门用于linux系统的，否则要将其擦写为ext4文件系统格式的，进入ubuntu的磁盘管理，选择自己的U盘，删除卷使其成为未分配，然后将其新建卷，文件系统选择ext4格式，并且要擦写，之后再挂载上来就可以用了。</p><p>然后<code>creat new</code>，等完成后，U盘里就会有sblive文件了，如果它小于4G，那么你可以直接在systemback里将它转为iso文件。但是如果大于4G，你就需要看下面这一点了：</p><h2 id="sblive文件大于4G该怎么转iso文件？"><a href="#sblive文件大于4G该怎么转iso文件？" class="headerlink" title="sblive文件大于4G该怎么转iso文件？"></a>sblive文件大于4G该怎么转iso文件？</h2><p>参考博客: <a href="https://blog.csdn.net/qq_39940390/article/details/94980229">Systemback无法将超过4G的sblive文件转存为镜像文件的解决办法</a>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">//1. 解压sblive文件<br><br>mkdir sblive<br>tar -xf /home/systemback_live_2016-04-27.sblive -C sblive<br><br><br>//2. 重命名syslinux为isolinux<br><br>mv sblive/syslinux/syslinux.cfg sblive/syslinux/isolinux.cfg<br>mv sblive/syslinux sblive/isolinux<br><br>//3. 安装cdtools<br>//若在安装aria2时，出现E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源临时不可用) <br>//请执行两条命令：<br>//sudo rm /var/cache/apt/archives/lock<br>//sudo rm /var/lib/dpkg/lock<br><br>sudo apt-get install aria2<br>aria2c -s 10 https://nchc.dl.sourceforge.net/project/cdrtools/alpha/cdrtools-3.02a07.tar.gz<br>tar -xzvf cdrtools-3.02a07.tar.gz<br><span class="hljs-built_in">cd</span> cdrtools-3.02<br>make<br>sudo make install<br><br>// 4.生成iso文件<br>//此操作前要<span class="hljs-built_in">cd</span>至sblive的上级目录，否则下面命令中的sblive请相应变化，确保能正确访问sblive<br><br>/opt/schily/bin/mkisofs -iso-level 3 -r -V sblive -cache-inodes -J -l -b isolinux/isolinux.bin -no-emul-boot -boot-load-size 4 -boot-info-table -c isolinux/boot.cat -o sblive.iso sblive<br><br></code></pre></td></tr></table></figure><p>现在你就得到了你自己ubuntu系统的iso镜像文件了，将它来装到一台机器上时，这个系统就和你原来使用的一模一样。</p><h1 id="卸载ubuntu"><a href="#卸载ubuntu" class="headerlink" title="卸载ubuntu"></a>卸载ubuntu</h1><p>有同学会说了，直接windows进入磁盘管理把linux的磁盘分区给删了格式化了，linux不就删了吗，这样是可以，但是在bios中的启动条目还是原来的ubuntu，这就需要我们清理干净了。下面进入windows界面开始操作：</p><ul><li>win+x选择（windows PowerShell（管理员））</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">diskpart<span class="hljs-comment"># 进入系统dispart组件</span><br><span class="hljs-built_in">list</span> disk<span class="hljs-comment"># 查看系统所有磁盘，并找到window系统所安装的磁盘,（会出现列表，比如你有两个硬盘，０和１）</span><br>select disk $<span class="hljs-comment"># 选择磁盘 $ 指window所安装的磁盘（列表，磁盘后的数字）(例如select disk 0)</span><br><span class="hljs-built_in">list</span> partition<span class="hljs-comment"># 找到类型为系统的分区（列表会显示）</span><br>select partition $<span class="hljs-comment"># $为类型为系统的分区　（例如select partition 0）</span><br>assign letter=p<span class="hljs-comment"># 将分区分配到磁盘P中，p是直接写得，不和c，d，e等盘冲突就可以了</span><br>exit <span class="hljs-comment"># 退出diskpat</span><br></code></pre></td></tr></table></figure><ul><li><p>此时我们会多出一个P盘，且没有访问权限，可以右击记事本以管理员身份运行，然后左上角文件打开P盘，找到EFI中的ubuntu文件夹并删除，其余不要动。</p><p><img src="https://img-blog.csdnimg.cn/20210425024026265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="以管理员身份运行记事本"></p><p><img src="https://img-blog.csdnimg.cn/20210425024055612.png" alt="P盘"></p><p><img src="https://img-blog.csdnimg.cn/20210425024117531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="P:EFI"></p></li><li><p>此时再次回到命令行操作，将P盘删掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">diskpart <span class="hljs-comment"># 再次进入到diskpart</span><br>select  disk $<span class="hljs-comment"># $是之前选择的盘符，如果记不住了，用list disk查看</span><br>selectpartition$<span class="hljs-comment"># $是之前选择的分区，如果记不住了，用list partition查看</span><br>remove letter=p <span class="hljs-comment"># 删除P盘，</span><br>exit<span class="hljs-comment"># 退出</span><br><br></code></pre></td></tr></table></figure><p>然后进入磁盘管理，将linux的盘区清理干净，删除卷，使其成为未分配状态。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210425024558175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="此电脑-管理"></p><p><img src="https://img-blog.csdnimg.cn/2021042502463313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="磁盘管理"></p><h1 id="重装ubuntu"><a href="#重装ubuntu" class="headerlink" title="重装ubuntu"></a>重装ubuntu</h1><p>下面这是我几个月前装的时候的做法，这里不赘述了<br>如何安装windows和linux双系统: <a href="https://blog.csdn.net/qq_43289711/article/details/110312956">https://blog.csdn.net/qq_43289711/article/details/110312956</a>.<br>大家进去看的时候一到在压缩卷的时候多压一点，至少50G才够用！！</p>]]></content>
    
    
    <categories>
      
      <category>双系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iso</tag>
      
      <tag>systemback</tag>
      
      <tag>cdrtools</tag>
      
      <tag>卸载ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链的简单实现</title>
    <link href="/Pages/2021/04/24/2021-04-24-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/Pages/2021/04/24/2021-04-24-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h1><p>一个维护着一个持续增长的有序数据记录列表的这么一个分布式数据库</p><p>下面我将简单用nodejs实现一个简单的区块链，它具有区块链的基本特性，但没有涉及PoS of PoW。</p><h1 id="块结构"><a href="#块结构" class="headerlink" title="块结构"></a>块结构</h1><p><img src="https://img-blog.csdnimg.cn/20210424100815475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="块结构"></p><p>一个块Block一般有：</p><ul><li>index   块号</li><li>previousHash   上一个区块的hash值</li><li>timestamp   时间戳</li><li>data   存放的数据</li><li>hash   区块的hash值</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Block</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(index, previousHash, timestamp, <span class="hljs-keyword">data</span>, hash) &#123;<br>        <span class="hljs-keyword">this</span>.index = index;<br>        <span class="hljs-keyword">this</span>.previousHash = previousHash;<br>        <span class="hljs-keyword">this</span>.timestamp = timestamp;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span>;<br>        <span class="hljs-keyword">this</span>.hash = hash.toString();<br>    &#125;<br>    toString()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&#123;\nindex:&quot;</span>+<span class="hljs-keyword">this</span>.index+<span class="hljs-string">&quot;,\npreviousHash:&#x27;&quot;</span>+<span class="hljs-keyword">this</span>.previousHash+<span class="hljs-string">&quot;&#x27;,\ntimestamp:&quot;</span>+<span class="hljs-keyword">this</span>.timestamp+<span class="hljs-string">&quot;,\ndata:&#x27;&quot;</span>+<span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>+<span class="hljs-string">&quot;&#x27;,\nhash:&#x27;&quot;</span>+<span class="hljs-keyword">this</span>.hash+<span class="hljs-string">&quot;&#x27;\n&#125;\n&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们每生成一个区块，我们都会给这个区块按照特定的hash算法，来得到一个hash值，一般来说，只要这个区块的index,previoushash,timestamp,data有改动，那么它所算出的hash值也会改变，所以当你想要篡改某个区块的数据时，你需要将后面所有的区块的previoushash都进行篡改。</p><h1 id="创世区块"><a href="#创世区块" class="headerlink" title="创世区块"></a>创世区块</h1><p>第一个区块是没有前置hash的，是特殊的一个区块，我们用代码将这个区块写死</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> genesisBlock = <span class="hljs-keyword">new</span> Block.Block(<br>    <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1619079309.946</span>, <span class="hljs-string">&quot;genesis block&quot;</span>, <span class="hljs-string">&#x27;80dea37cccca5fb56b9b78dbe2733fb19e8ee2aa7bb03d4ac1e361fe3fad7b51&#x27;</span><br>);<br></code></pre></td></tr></table></figure><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>本文采用sha256来求得hash值</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">exports.caHash=<span class="hljs-function"><span class="hljs-keyword">function</span></span> (<span class="hljs-built_in">index</span>, previousHash, timestamp, <span class="hljs-keyword">data</span>)&#123;<br>   <span class="hljs-keyword">return</span> sha256(<span class="hljs-built_in">index</span> + previousHash + timestamp + <span class="hljs-keyword">data</span>).toString();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="验证块的有效性"><a href="#验证块的有效性" class="headerlink" title="验证块的有效性"></a>验证块的有效性</h1><p>下面是验证单个块是否有效，可以根据下面遍历整个链是否有效。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vaild<span class="hljs-constructor">Block(<span class="hljs-params">block</span>,<span class="hljs-params">lastBlock</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Block</span>.</span></span>is<span class="hljs-constructor">ValidBlockStructure(<span class="hljs-params">block</span>)</span>)<br>            return <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<br>            (block.index==lastBlock.index+<span class="hljs-number">1</span>)<br>            &amp;&amp;(block.previousHash==lastBlock.previousHash)<br>            &amp;&amp;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Block</span>.</span></span>ca<span class="hljs-constructor">Hash(<span class="hljs-params">block</span>.<span class="hljs-params">index</span>,<span class="hljs-params">block</span>.<span class="hljs-params">previousHash</span>,<span class="hljs-params">block</span>.<span class="hljs-params">timestamp</span>,<span class="hljs-params">block</span>.<span class="hljs-params">data</span>)</span><br>        )<br>            return <span class="hljs-literal">true</span>;<br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="记录数据"><a href="#记录数据" class="headerlink" title="记录数据"></a>记录数据</h1><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">creatBlock(data)&#123;<br>        <span class="hljs-keyword">var</span> lastBlock=<span class="hljs-built_in">this</span>.getLastBlock();<br>        <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Index</span>=lastBlock.index+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Time</span>=<span class="hljs-keyword">new</span> <span class="hljs-type">Date</span>().getTime()/<span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">PreHash</span>=lastBlock.hash;<br>        <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">hash</span>=Block.caHash(<span class="hljs-keyword">new</span><span class="hljs-type">Index</span>,<span class="hljs-keyword">new</span><span class="hljs-type">PreHash</span>,<span class="hljs-keyword">new</span><span class="hljs-type">Time</span>,data.toString());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.blocks[<span class="hljs-built_in">this</span>.blocks.length]= <span class="hljs-keyword">new</span> <span class="hljs-type">Block</span>.Block(<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Index</span>, <span class="hljs-keyword">new</span><span class="hljs-type">PreHash</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Time</span>, data, <span class="hljs-keyword">new</span><span class="hljs-type">hash</span><br><span class="hljs-type"></span>        );<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="从其他节点接收一个块"><a href="#从其他节点接收一个块" class="headerlink" title="从其他节点接收一个块"></a>从其他节点接收一个块</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">addBlock(block)&#123;<br>        <span class="hljs-keyword">if</span> (validBlock(block,<span class="hljs-keyword">this</span>.getLastBlock()))&#123;<br>            blocks.push(block);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var Chain=require(<span class="hljs-string">&quot;./Chain&quot;</span>);<br>var BlockChain=<span class="hljs-keyword">new</span> Chain.<span class="hljs-constructor">BlockChain()</span>;<br>var http=require(&#x27;http&#x27;);<br>var fs=require(&#x27;fs&#x27;);<br>var querystring=require(&#x27;querystring&#x27;);<br><br>var server=http.create<span class="hljs-constructor">Server(<span class="hljs-params">function</span> (<span class="hljs-params">req</span>,<span class="hljs-params">res</span>)</span> &#123;<br>    var url=req.url;<br>    <span class="hljs-keyword">if</span> (url==<span class="hljs-string">&quot;/get&quot;</span>)&#123;<br>        res.write<span class="hljs-constructor">Head(200,&#123;&#x27;<span class="hljs-params">content</span>-<span class="hljs-params">type</span>&#x27;:&#x27;<span class="hljs-params">text</span><span class="hljs-operator">/</span><span class="hljs-params">plain</span>&#x27;+&#x27;<span class="hljs-params">charset</span>=UTF8&#x27;&#125;)</span>;<br>        var str=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BlockChain</span>.</span></span>blocks;<br>        res.<span class="hljs-keyword">end</span>(str.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url==<span class="hljs-string">&quot;/creat&quot;</span>)&#123;<br>        var data=<span class="hljs-literal">[]</span>;<br>        req.on(&#x27;data&#x27;,<span class="hljs-keyword">function</span> (chunk) &#123;<br>            data.push(chunk);<br>        &#125;)<br>        req.on(&#x27;<span class="hljs-keyword">end</span>&#x27;,<span class="hljs-keyword">function</span> (chunk)&#123;<br>            var dataObj=querystring.parse(data.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>)<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BlockChain</span>.</span></span>creat<span class="hljs-constructor">Block(<span class="hljs-params">dataObj</span>[<span class="hljs-string">&quot;data&quot;</span>])</span>;<br>            var lastblock=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BlockChain</span>.</span></span>get<span class="hljs-constructor">LastBlock()</span>;<br>            res.set<span class="hljs-constructor">Header(&#x27;<span class="hljs-params">content</span>-<span class="hljs-params">type</span>&#x27;,&#x27;<span class="hljs-params">text</span><span class="hljs-operator">/</span><span class="hljs-params">plain</span>;<span class="hljs-params">charset</span>=UTF8&#x27;)</span>;<br>            res.write(lastblock.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>            res.<span class="hljs-keyword">end</span>(<span class="hljs-string">&quot;生成区块&quot;</span>+lastblock.index+<span class="hljs-string">&quot;号成功！&quot;</span>);<br>        &#125;)<br><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        res.set<span class="hljs-constructor">Header(&#x27;<span class="hljs-params">content</span>-<span class="hljs-params">type</span>&#x27;,&#x27;<span class="hljs-params">text</span><span class="hljs-operator">/</span><span class="hljs-params">html</span>;<span class="hljs-params">charset</span>=UTF8&#x27;)</span>;<br>        fs.read<span class="hljs-constructor">File(&#x27;.<span class="hljs-operator">/</span><span class="hljs-params">client</span>.<span class="hljs-params">html</span>&#x27;,<span class="hljs-params">function</span> (<span class="hljs-params">err</span>,<span class="hljs-params">data</span>)</span> &#123;<br>            res.write(data);<br>            res.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>;<br>        &#125;)<br>    &#125;<br><br>&#125;);<br>server.listen(<span class="hljs-number">2345</span>);<br></code></pre></td></tr></table></figure><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p><img src="https://img-blog.csdnimg.cn/20210424113050899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="输入数据"></p><p>输入一些数据，然后点击生成区块：</p><p><img src="https://img-blog.csdnimg.cn/2021042411312155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="点击生成区块后结果"></p><p>点击获取区块链：</p><p><img src="https://img-blog.csdnimg.cn/20210424113227426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="点击获取区块链后结果"></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>你可以从仓库里获取完整代码：</p><p>github: <a href="https://github.com/Lixingwei0623/ablockchain">https://github.com/Lixingwei0623/ablockchain</a>.<br>gitee: <a href="https://gitee.com/li-xingwei/simple-block-chain">https://gitee.com/li-xingwei/simple-block-chain</a>.</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下idea、pycharm等输入中文拼音时满3个字母后无法继续拼音输入</title>
    <link href="/Pages/2021/04/08/2021-04-21-linux%E4%B8%8Bidea%E3%80%81pycharm%E7%AD%89%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E6%8B%BC%E9%9F%B3%E6%97%B6%E6%BB%A13%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%90%8E%E6%97%A0%E6%B3%95%E7%BB%A7%E7%BB%AD%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%EF%BC%88%E9%97%AE%E9%A2%98%E5%B8%A6%E5%9B%BE%E6%8F%8F%E8%BF%B0%EF%BC%81%EF%BC%81%EF%BC%89/"/>
    <url>/Pages/2021/04/08/2021-04-21-linux%E4%B8%8Bidea%E3%80%81pycharm%E7%AD%89%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E6%8B%BC%E9%9F%B3%E6%97%B6%E6%BB%A13%E4%B8%AA%E5%AD%97%E6%AF%8D%E5%90%8E%E6%97%A0%E6%B3%95%E7%BB%A7%E7%BB%AD%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%EF%BC%88%E9%97%AE%E9%A2%98%E5%B8%A6%E5%9B%BE%E6%8F%8F%E8%BF%B0%EF%BC%81%EF%BC%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述：idea输入中文，没输入几个拼音就好像自动回车，有时得到几个字母，然后就不能输入拼音了。"><a href="#问题描述：idea输入中文，没输入几个拼音就好像自动回车，有时得到几个字母，然后就不能输入拼音了。" class="headerlink" title="问题描述：idea输入中文，没输入几个拼音就好像自动回车，有时得到几个字母，然后就不能输入拼音了。"></a>问题描述：idea输入中文，没输入几个拼音就好像自动回车，有时得到几个字母，然后就不能输入拼音了。</h1><p><img src="https://img-blog.csdnimg.cn/20210421220812103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="无法拼音"><img src="https://img-blog.csdnimg.cn/2021042122085224.png" alt="在这里插入图片描述"></p><p>遇到这个情况就导致输入中文特别困难，可以采取：</p><h2 id="修改idea-sh和pycharm-sh文件来改变语言输入设置。"><a href="#修改idea-sh和pycharm-sh文件来改变语言输入设置。" class="headerlink" title="修改idea.sh和pycharm.sh文件来改变语言输入设置。"></a>修改idea.sh和pycharm.sh文件来改变语言输入设置。</h2><h2 id="找到自己idea或pycharm安装的地方，-bin-idea-sh"><a href="#找到自己idea或pycharm安装的地方，-bin-idea-sh" class="headerlink" title="找到自己idea或pycharm安装的地方，/bin/idea.sh"></a>找到自己idea或pycharm安装的地方，/bin/idea.sh</h2><p><img src="https://img-blog.csdnimg.cn/20210421221531462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="bin目录"></p><h2 id="编辑idea-sh文件，在最后新增以下几行代码："><a href="#编辑idea-sh文件，在最后新增以下几行代码：" class="headerlink" title="编辑idea.sh文件，在最后新增以下几行代码："></a>编辑idea.sh文件，在最后新增以下几行代码：</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XIM</span>=<span class="hljs-string">&quot;ibus&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XIM_PROGRAM</span>=<span class="hljs-string">&quot;ibus&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XMODIFIERS</span>=<span class="hljs-string">&quot;@im=ibus&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GTK_IM_MODULE</span>=<span class="hljs-string">&quot;ibus&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">QT_IM_MODULE</span>=<span class="hljs-string">&quot;ibus&quot;</span><br></code></pre></td></tr></table></figure><p>此处每行代码的ibus要根据自己系统的输入法来设置，有的是fcitx，可以在设置里看，点击下图的管理已安装语言出现语言支持对话框，键盘输入法系统：IBus</p><p><img src="https://img-blog.csdnimg.cn/20210421222350236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="ibus输入系统"></p><p>如果你是fcitx的话，请在idea.sh里加入：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XIM</span>=<span class="hljs-string">&quot;fcitx&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XIM_PROGRAM</span>=<span class="hljs-string">&quot;fcitx&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XMODIFIERS</span>=<span class="hljs-string">&quot;@im=fcitx&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GTK_IM_MODULE</span>=<span class="hljs-string">&quot;fcitx&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">QT_IM_MODULE</span>=<span class="hljs-string">&quot;fcitx&quot;</span><br></code></pre></td></tr></table></figure><h2 id="然后source-etc-profile更新一下配置文件，重启idea就可以了输入中文了"><a href="#然后source-etc-profile更新一下配置文件，重启idea就可以了输入中文了" class="headerlink" title="然后source /etc/profile更新一下配置文件，重启idea就可以了输入中文了"></a>然后<code>source /etc/profile</code>更新一下配置文件，重启idea就可以了输入中文了</h2><p><img src="https://img-blog.csdnimg.cn/202104212219562.png" alt="中文输入"></p><h1 id="Pycharm同理更改pycharm-sh文件"><a href="#Pycharm同理更改pycharm-sh文件" class="headerlink" title="Pycharm同理更改pycharm.sh文件"></a>Pycharm同理更改pycharm.sh文件</h1><h1 id="注：这种情况一般是正常的配置没有被加载进来，如果是使用环境变量来通过命令行idea-sh的方式进入的话，大概率会有问题。"><a href="#注：这种情况一般是正常的配置没有被加载进来，如果是使用环境变量来通过命令行idea-sh的方式进入的话，大概率会有问题。" class="headerlink" title="注：这种情况一般是正常的配置没有被加载进来，如果是使用环境变量来通过命令行idea.sh的方式进入的话，大概率会有问题。"></a>注：这种情况一般是正常的配置没有被加载进来，如果是使用环境变量来通过命令行idea.sh的方式进入的话，大概率会有问题。</h1><p>可以先从idea的bin目录下，./idea来运行idea，然后进入后发现是可以正常输入中文的，然后在Tools-&gt;Create Desktop Entry来创建快捷方式，以后通过快捷方式进入就不会有问题了。</p>]]></content>
    
    
    <categories>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误</tag>
      
      <tag>idea</tag>
      
      <tag>设置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学基础</title>
    <link href="/Pages/2021/04/08/2021-04-08-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80(%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86)/"/>
    <url>/Pages/2021/04/08/2021-04-08-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80(%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86)/</url>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>一般分为：</p><ul><li>对称加密</li><li>非对称加密<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2>加密和解密使用的是同一个密钥或者，两者可以互相推导得出，则认为是对称加密，如DES，AES，3DES<blockquote><p>在传输数据时用密钥将数据加密，然后将密文发给接收方，接收方再使用该密钥解密数据。这样就要求接收方需要知道密钥，如果接收方需要接受1万个用户的数据的话就需要知道1万个密钥，并且密钥容易泄漏。</p></blockquote><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2>加密和解密的密钥不同，且知道其中一个密钥不能得知另一个密钥，一般用来加密的密钥称作公钥，用来解密的密钥称作私钥，如RSA，ECC<blockquote><p>在需要传输数据给某用户时，就使用该用户的公钥对数据加密得到密文发给用户，用户用自己的私钥来解密密文得到数据 。</p></blockquote><h2 id="两类加密的特点"><a href="#两类加密的特点" class="headerlink" title="两类加密的特点"></a>两类加密的特点</h2></li><li>对称加密安全性差，但是效率高</li><li>非对称加密安全性好，但是加密效率低<h2 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h2>在传输一个比较大的数据时，可以先用对称加密来加密数据，对称加密的密钥假如为X，再用非对称加密将X加密。<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><blockquote><p>凯撒密码是对称密码，其密钥是0-26的一个整数key，加密是将每个字母往后推移key个字母<br>比如密钥为3，明文为a，则密文就是d</p></blockquote><h2 id="代码实现-加密"><a href="#代码实现-加密" class="headerlink" title="代码实现-加密"></a>代码实现-加密</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//加密</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> encryption(<span class="hljs-keyword">String</span> txt,<span class="hljs-built_in">int</span> <span class="hljs-built_in">key</span>)&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span>&lt;<span class="hljs-number">0</span>||<span class="hljs-built_in">key</span>&gt;<span class="hljs-number">26</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-built_in">char</span>[] result=txt.toCharArray();<br>        <span class="hljs-built_in">int</span> intA=<span class="hljs-number">65</span>;<br>        <span class="hljs-built_in">int</span> inta=<span class="hljs-number">97</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;result.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (result[i]&gt;<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;result[i]&lt;<span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>                result[i] =(<span class="hljs-built_in">char</span>)(((<span class="hljs-built_in">int</span>)result[i]+<span class="hljs-built_in">key</span>-intA)%<span class="hljs-number">26</span>+intA);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result[i]&gt;<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;result[i]&lt;<span class="hljs-string">&#x27;z&#x27;</span>)&#123;<br>                result[i] =(<span class="hljs-built_in">char</span>)(((<span class="hljs-built_in">int</span>)result[i]+<span class="hljs-built_in">key</span>-inta)%<span class="hljs-number">26</span>+inta);<br>            &#125;<span class="hljs-keyword">else</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(result);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="代码实现-解密"><a href="#代码实现-解密" class="headerlink" title="代码实现-解密"></a>代码实现-解密</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//解密，调用加密的函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> decrypting(<span class="hljs-keyword">String</span> txt,<span class="hljs-built_in">int</span> <span class="hljs-built_in">key</span>)&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span>&lt;<span class="hljs-number">0</span>||<span class="hljs-built_in">key</span>&gt;<span class="hljs-number">26</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> encryption(txt,<span class="hljs-number">26</span>-<span class="hljs-built_in">key</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="main函数及文件加密"><a href="#main函数及文件加密" class="headerlink" title="main函数及文件加密"></a>main函数及文件加密</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        Scanner scanner=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br>        <span class="hljs-built_in">int</span> choose=<span class="hljs-number">0</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;加密输入1，解密输入2：&quot;</span>);<br>        choose=scanner.next<span class="hljs-constructor">Int()</span>;<br>        <span class="hljs-keyword">if</span> (choose==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;输入密钥（0-26）：&quot;</span>);<br>            <span class="hljs-built_in">int</span> key=scanner.next<span class="hljs-constructor">Int()</span>;<br>            String pathname=<span class="hljs-string">&quot;/new/IdeaProjects/StudyTest/test.txt&quot;</span>;<br>            String oriText=get<span class="hljs-constructor">FileText(<span class="hljs-params">pathname</span>)</span>;<br>            String ciphertext=encryption(oriText,key);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(pathname+<span class="hljs-string">&quot;加密完成!&quot;</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;使用密钥：&quot;</span>+key+<span class="hljs-string">&quot;加密后得到密文为：&quot;</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(ciphertext);<br>            String pathname2=<span class="hljs-string">&quot;/new/IdeaProjects/StudyTest/ciphertext.txt&quot;</span>;<br>            <span class="hljs-keyword">if</span> (print<span class="hljs-constructor">ToFile(<span class="hljs-params">ciphertext</span>,<span class="hljs-params">pathname2</span>)</span>)&#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;密文保存在：&quot;</span>+pathname2);<br>                return;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;密文保存失败！&quot;</span>);<br>                return;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (choose==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;输入密钥（0-26）：&quot;</span>);<br>            <span class="hljs-built_in">int</span> key=scanner.next<span class="hljs-constructor">Int()</span>;<br>            String pathname2=<span class="hljs-string">&quot;/new/IdeaProjects/StudyTest/ciphertext.txt&quot;</span>;<br>            String cipherText=get<span class="hljs-constructor">FileText(<span class="hljs-params">pathname2</span>)</span>;<br>            String oriText=decrypting(cipherText,key);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;使用密钥：&quot;</span>+key+<span class="hljs-string">&quot;解密完成，明文为：&quot;</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(oriText);<br><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            return;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//读文件</span><br>    public static String get<span class="hljs-constructor">FileText(String <span class="hljs-params">pathname</span>)</span>&#123;<br>        File file=<span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">pathname</span>)</span>;<br>        String str=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(<span class="hljs-params">file</span>)</span>;<br>            <span class="hljs-keyword">while</span>(scanner.has<span class="hljs-constructor">Next()</span>)<br>            &#123;<br>                str=str+<span class="hljs-string">&quot; &quot;</span>+scanner.next<span class="hljs-literal">()</span>;<br>            &#125;<br>            scanner.close<span class="hljs-literal">()</span>;<br>        &#125; catch (FileNotFoundException e) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;file not found.&quot;</span>);<br>        &#125;<br>        return  str;<br>    &#125;<br><br>    <span class="hljs-comment">//写文件</span><br>    public static boolean print<span class="hljs-constructor">ToFile(String <span class="hljs-params">str</span>,String <span class="hljs-params">pathname</span>)</span>&#123;<br>        File file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">pathname</span>)</span>;<span class="hljs-comment">// 要写入的文件路径</span><br>        <span class="hljs-keyword">if</span> (!file.exists<span class="hljs-literal">()</span>) &#123;<span class="hljs-comment">// 判断文件是否存在</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                file.create<span class="hljs-constructor">NewFile()</span>;<span class="hljs-comment">// 如果文件不存在创建文件</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;文件&quot;</span>+file.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;已为您创建!&quot;</span>);<br>            &#125; catch (IOException e) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;创建文件异常!&quot;</span>);<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>                return <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;文件&quot;</span>+file.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;已存在!&quot;</span>);<br>        &#125;<br><br><br>        FileOutputStream fos = null;<br>        PrintStream ps = null;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fos = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileOutputStream(<span class="hljs-params">file</span>,<span class="hljs-params">true</span>)</span>;<span class="hljs-comment">// 文件输出流追加</span><br>            ps = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PrintStream(<span class="hljs-params">fos</span>)</span>;<br>        &#125; catch (FileNotFoundException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>        String <span class="hljs-built_in">string</span>  = str + <span class="hljs-string">&quot;\r\n&quot;</span>;<span class="hljs-comment">// +换行</span><br>        ps.print(<span class="hljs-built_in">string</span>); <span class="hljs-comment">// 执行写操作</span><br>        ps.close<span class="hljs-literal">()</span>;<span class="hljs-comment">// 关闭流</span><br><br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对称加密</tag>
      
      <tag>非对称加密</tag>
      
      <tag>凯撒密码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP基础上手</title>
    <link href="/Pages/2021/03/06/2021-03-06-PHP%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/"/>
    <url>/Pages/2021/03/06/2021-03-06-PHP%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li><p>定义变量不需要规定数据类型</p></li><li><p>变量名以 “$” 符号开头，只能包含数字、字母、下划线，不能数字开头</p></li><li><p>使用unset函数清除变量</p></li><li><p>预定义变量</p><pre><code>$_GET：存储以get方式提交的表单$_POST：存储以post方式提交的表单$_REQUEST：存储以get或post方式提交的表单$GLOBALS：存储PHP中所有全局变量$_SERVER：服务器信息$_SESSIOON：session会话信息$_COOKIE：cookie会话信息$_ENV：环境信息$_FILES：用户上传的文件信息</code></pre></li><li><p>可变变量：一个变量的内容可作为另一变量的名字</p><pre><code>$a=&#39;b&#39;;$b=&#39;bb&#39;;//   $$a ==&#39;bb&#39;</code></pre></li></ol><p>变量赋值与值传递</p><pre><code>$a = 1;$b = $a;    //值传递，将a值复制一份给b$c = &amp;$a;    //引用传递，指向同一个值（内存空间）</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><pre><code>//使用define函数定义define(&#39;PI&#39;,3.14,(false));    //最后的false表示大小写敏感，可省略；若定义为true则大小写不敏感//使用const关键字定义const PII = 3;//使用define函数定义特殊常量define(&#39;&gt;_&lt;&#39;,&#39;smile&#39;);//使用常量echo PI;//用constant函数访问常量echo constant(&#39;&gt;_&lt;&#39;);</code></pre><p>常量名字不用$符号（会被系统当作变量）<br>常量名由字母、数字、下划线组成，不能以数字开头，通常以大写字母为主（与变量区分）<br>使用define方式定义的常量名中可以使用一些特殊字符，但访问时只能用constant函数<br>系统常量</p><pre><code>PHP_VERSION：PHP版本号__DIR__：当前php脚本所在绝对路径__FILE__：当前php脚本所在绝对路径加文件名__LINE__：当前语句（引用该常量的语句）所在行__NAMESPACE__：当前所属命名空间__CLASS__：当前所属的类__METHOD__：当前所属的方法</code></pre><h2 id="数据类型与运算符"><a href="#数据类型与运算符" class="headerlink" title="数据类型与运算符"></a>数据类型与运算符</h2><p>数据类型<br>简单（基本）数据类型</p><ol><li><p>整型：int，4字节，表示整数，默认有符号</p><pre><code>$a = 120;    //十进制$b = 0b110;        //二进制$c = 0120;        //八进制$d = 0x12a;        //十六进制//输出时默认为十进制，进制间转换可用函数，如：dexbin()为十进制转二进制</code></pre></li><li><p>浮点型：float/double，8字节，表示小数或整型存不下的整数</p></li><li><p>字符串型：string，大小按实际长度分配，表示字符串</p></li><li><p>布尔类型：bool，表示true和false</p></li><li><p>复合数据类型</p></li></ol><p>对象类型：object，存放对象<br>数组类型：array，存放数组（一次性）</p><ol start="6"><li>特殊数据类型</li></ol><p>资源类型：resource，存放资源数据（PHP外部数据，如数据库、文件）<br>空类型：NULL<br>数据类型的转换</p><p>其他类型转bool类型：除 0，“0”，NULL，空字符串 外，均为true<br>bool类型转数值：true为1，false为0<br>字符串类型转数值：以字母开头的字符串永远为0；以数字开头的字符串，数值为遇到字母或第二个小数点前为止<br>强制类型转换：（需转换的类型）+需转换的变量或表达式，不改变原变量的数据类型<br>数据类型的判断</p><p>通过以is_开头后跟数据类型的函数判断：is_类型(变量名)。函数返回值用var_dump函数查看。</p><p>用var_dump函数查看：var_dump(变量名)</p><p>用一组可获取或设定类型的函数</p><pre><code>echo gettype($a);    //获取数据类型settype($a,&#39;int&#39;);    //设定数据类型，与强制类型转换不同，会改变原变量的数据类型  empty();    //判断数据是否为空(NULL)或0，为空返回true，反之false  isset();    //判断变量是否存在，存在返回true，反之false</code></pre><p>运算符<br>赋值、算术运算符：赋值运算”=”，加法”+”，减法”-“，乘法”*”，除法”/“，取余运算”%”，自加运算”++”，自减运算”–”</p><p>比较运算符</p><pre><code>&gt;,&lt;,&gt;=,&lt;=,==,!=：大于，小于，大于等于，小于等于，等于，不等于===,!==：全等于（数据大小与类型都相同），不全等于（大小或类型不同）$a = &#39;123&#39;;$b = 123;var_dump($a == $b);        //返回truevar_dump($a === $b);        //返回false</code></pre><p>逻辑运算符：逻辑与”&amp;&amp;”，逻辑或”||”，逻辑非”!”</p><p>连接运算符：”.”，将两个字符串拼接在一起；”.=”，字符串拼接后赋值给左边</p><p>错误抑制符：”@”，在可能出错的语句前加上@符号可关闭错误回显</p><p>三目运算符：“表达式1 ? 表达式2 : 表达式3”，表达式1成立时执行表达式2，否则执行表达式3</p><p>位运算符：”&amp;“按位与，两个位都为1则为1；”|“按位或，两个位有一个为1则为1；”~“按位非，将位取反；”^“按位异或，两个位相同为0，不同为1；”&lt;&lt;“按位左移，右边补0；”&gt;&gt;”，按位右移，左边补符号位内容</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>if结构，while循环，du-while循环，for循环，switch结构与C语言大体相同</p><p>流程控制替代语法：增强PHP+HTML的易读性与美观性</p><p>例：打印九九乘法表</p><pre><code>&lt;table border=1&gt;    &lt;?php for($i = 1;$i &lt; 10;$i++):        //for循环的大括号可由 : 与 endfor; 代替 ?&gt;    &lt;tr&gt;        &lt;?php for($j = 1;$j &lt;= $i;$j++): ?&gt;        &lt;td&gt;            &lt;?php echo $i . &#39; * &#39; . $j . &#39; = &#39;. $i * $j; ?&gt;        &lt;/td&gt;        &lt;?php endfor;?&gt;    &lt;/tr&gt;    &lt;?php endfor;?&gt;&lt;/table&gt;</code></pre><!--    相似的结构还有if,switch,while,foreach    --><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>实质上是将文件中内容嵌入另一文件中相应位置</p><p>文件包含的两种方法</p><p>向上包含：使用被包含文件中的数据<br>向下包含：将本文件中的数据通过被包含文件中的方式显示<br>文件包含的四种形式</p><p>include , require：包含文件。语法：include ‘文件名’; 或 include(‘文件名’)，文件不在当前目录时要用绝对路径（安全）或相对路径（高效），下同</p><p>_注：绝对路径：本地绝对路径（从磁盘根目录开始）与网络绝对路径（相对于网站主机名对应的路径）；相对路径：_相对于当前文件的路径，./ 表示当前目录，../表示上级目录</p><p>include_once , require_once：系统判断是否已包含文件，使得对应文件只包含一次</p><p>include与require区别</p><p>在包含文件出错时，include报错级别较低，后面代码会继续执行；require报错级别较高，代码会立即停止执行</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>function，一种语法结构，将一个代码块封装到一个结构中。</p><p>关键点：function关键字，函数名，参数，函数体，返回值</p><p>基本语法：</p><pre><code>function 函数名([参数])&#123;    //函数体    return 结果;        //返回值&#125;</code></pre><p>注意：</p><p>实参不能少于形参个数，多余参数函数不会使用。函数定义时可为形参初始化一个默认值，使得提供参数过少时函数可正常执行。例：</p><pre><code>function test($num1,$num2=0)        //有默认值的参数应放在最右边&#123;    echo $num1+$num2;        //传入参数不足时使用默认值0&#125;</code></pre><p>当函数想改变传入实参存储的值时，在定义函数时形参前加上”&amp;”取地址符号，即地址传递</p><p>return返回值可在函数中使用，也可以在文件中使用（包含文件的返回值）,return后的语句不执行</p><p>如果有变量的值恰好为函数名，那么调用函数可以通过变量+()，如：$变量([参数])</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>全局变量：在函数外部定义的变量，函数体内不能直接访问，需要传值<br>局部变量：在函数内部定义的变量，只能在函数体内使用<br>超全局变量：一些预定义变量，如$GLOBALS等<br>在函数内使用global关键字定义的变量，在函数外部也能使用（系统自动在全局区定义相同变量，并将两个变量指向同一内存空间）；若函数外部存在同名变量，系统自动将两个变量合并（直接指向外部全局变量内存空间）<br>静态变量：在函数中用static关键字定义的变量（在定义时应同时赋值），在函数调用结束后，内存空间不会被清空，在函数下次调用时仍可访问之前的数据，且不会被重复初始化<br>匿名函数<br>没有名字的函数</p><p>基本语法：</p><pre><code>//定义基本匿名函数$func = function()&#123;    echo &#39;hello world&#39;;&#125;;        //此处应有分号//调用匿名函数$func()</code></pre><p>变量保存匿名函数，本质上得到的是一个对象（closure）</p><h2 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h2><h3 id="有关输出的函数"><a href="#有关输出的函数" class="headerlink" title="有关输出的函数"></a>有关输出的函数</h3><p>print()：类似于echo，返回值为1，可以不用括号<br>print_r()：类似于var_dump，但不会输出数据类型，只会输出值（常用于打印数组）</p><h3 id="有关时间的函数"><a href="#有关时间的函数" class="headerlink" title="有关时间的函数"></a>有关时间的函数</h3><p>date()：按照指定格式格式化时间戳，没有指定格式将按照默认格式。具体参数<br>time()：获取当前时间对应的时间戳（无参数）<br>microtime()：获取微秒级别的时间</p><h3 id="有关数学的函数"><a href="#有关数学的函数" class="headerlink" title="有关数学的函数"></a>有关数学的函数</h3><p>max()，min()：分别返回参数中最大的值和最小的值<br>rand([参数1],参数2)：得到一个在区间内的随机数（包括两个参数），参数1可不提供<br>mt_rand()：与rand函数相同，但效率更高<br>round()：四舍五入<br>ceil()：向上取整，得到比参数大的最小整数<br>floor()：向下取整，得到比参数小的最大整数<br>pow(参数1,参数2)：得到参数1的参数2次方<br>abs()：绝对值<br>sqrt()：平方根</p><h3 id="有关函数的函数"><a href="#有关函数的函数" class="headerlink" title="有关函数的函数"></a>有关函数的函数</h3><p>function_exists()：判断指定函数名字是否在内存中存在<br>func_get_arg(n)：在自定义函数中去获取第n-1 个参数<br>func_get_args()：在自定义函数中去获取所有参数（返回一个数组）<br>func_num_args()：获取当前自定义函数的参数数量</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误代号<br>所有错误代码会被系统定义为系统常量，可以直接使用</p><p>系统错误<br>E_PARSE：编译错误<br>E_ERROR：fatal error，致命错误，会导致代码不能正确执行（出错的位置断掉）<br>E_WARNING：warning，警告错误，不会影响代码执行，但可能会得到意想不到的结果<br>E_NOTICE：通知错误，不会影响代码执行<br>用户错误：E_USER_ERROR，E_USER_WARNING，E_USER_NOTICE，用户在使用自定义错误触发的时候会使用到（系统不会用到）<br>其他：E_ALL，代表所有错误，建议在开发环境中使用<br>所有以E开头的错误常量（代号）都存储在一个字节内，每种占据一个位，所以可以通过位运算来进行一些错误的控制，例：</p><p>排除通知级别的错误：E_ALL &amp; ~E_NOTICE</p><p>只要警告和通知级别：E_WARNING | E_NOTICE</p><h3 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h3><p>程序运行时触发：主要针对代码语法错误和运行时错误，由系统自动生成<br>人为触发：人为使用对应判断代码来触发错误提示<br>trigger_error(提示内容,[错误级别])：人为触发错误，错误级别默认为E_USER_NOTICE，不影响下面执行</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串定义"><a href="#字符串定义" class="headerlink" title="字符串定义"></a>字符串定义</h3><p>普通定义：使用单引号或双引号包裹</p><p>结构化定义</p><p>nowdoc定义</p><pre><code>$str = &lt;&lt;&lt;&#39;ABC&#39;                        //上边界符，可随意命名，后面不能有内容****内容****ABC;        //下边界符必须顶格</code></pre><p>heredoc定义</p><pre><code>$str = &lt;&lt;&lt;CBA****内容****CBA;</code></pre><p>注意：</p><p>普通定义中，使用单引号包裹的字符串只能识别 \’ 转义字符，其他转义字符原样输出；使用双引号包裹的字符串只识别不了 \’ 转义字符，其他转义字符按转义后形态输出——也就是说，双引号包裹的字符串中当符 号 未 转 义 时 ， 可 以 用 来 解 析 变 量 （ 前 提 是 系 统 能 区 分 变 量 与 其 后 面 的 字 符 串 ， 而 不 是 连 在 一 起 ， 比 如 符号未转义时，可以用来解析变量（前提是系统能区分变量与其后面的字符串，而不是连在一起，比如符号未转义时，可以用来解析变量（前提是系统能区分变量与其后面的字符串，而不是连在一起，比如a bcd与$abcd）<br>结构化定义中，边界符之间的内容全部原样输出</p><h3 id="字符串长度问题"><a href="#字符串长度问题" class="headerlink" title="字符串长度问题"></a>字符串长度问题</h3><p>基本函数strlen()：得到字符串的长度（单位：字节）<br>多字节字符串长度问题：中文在utf-8字符集下占3个字节<br>多字节字符串拓展模块：mbstring拓展<br>字符串长度函数mb_strlen(string $str[,string $encoding])，第二个参数为指定字符集，未指定则为默认的ASCII</p><h3 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h3><p>转换函数：implode(),explode(),str_split()<br>截取函数：trim(),ltrim(),rtrim(),substr(),strstr()<br>大小转换函数：strtolower(),strtoupper(),ucfirst()<br>查找函数：strpos(),strrpos()<br>替换函数：str_replace()<br>格式化函数：printf(),sprintf()<br>其他：str_repeat(),str_shuffle()</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><p>使用array关键字（常用）</p><p>$a = array(元素1,元素2,……);<br>$b = array(下标=&gt;元素,……);<br>1<br>2<br>使用中括号包裹数据</p><p>$a = [元素1,元素2,……]；<br>1<br>给变量加上中括号</p><p>$a[] = 值;<br>$a[下标] = 值;<br>1<br>2<br>注意：</p><p>下标可以为整数或字符串，可以混用<br>元素顺序以放入时顺序为准，与下标无关<br>特殊值下标：true——1，false——0，NULL——“”<br>php中数组元素没有类型限制，没有长度限制<br>PHP多维数组：即数组元素也是数组，建议不超过三维</p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><pre><code>foreach($数组 as [$下标 =&gt;] $值)&#123;    //输出函数&#125;//例：foreach($arr as $k =&gt; $v)&#123;    echo $k , &#39;==&#39; , $v        //$k,$v为函数内变量&#125;</code></pre><h3 id="数组相关函数"><a href="#数组相关函数" class="headerlink" title="数组相关函数"></a>数组相关函数</h3><p>排序函数：sort(),rsort(),arsort(),ksort(),shuffle()<br>指针函数：reset(),end(),next(),prev(),current(),key()<br>其他函数：count(),array_push(),array_pop(),array_shift(),array_unshift(),array_reverse(),in_array(),array_keys(),array_values()</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>编程语言</category>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>入门</tag>
      
      <tag>数据类型</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js初学</title>
    <link href="/Pages/2021/02/20/2021-02-20-Node.js%E5%9F%BA%E7%A1%80/"/>
    <url>/Pages/2021/02/20/2021-02-20-Node.js%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="1-node-js简介"><a href="#1-node-js简介" class="headerlink" title="1.node.js简介"></a>1.node.js简介</h2><p>node.js基于chrom8，相当于一个运行js代码的虚拟平台，使得js不在依存html，可以构建服务器。</p><h2 id="2-node-js搭建服务器"><a href="#2-node-js搭建服务器" class="headerlink" title="2.node.js搭建服务器"></a>2.node.js搭建服务器</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var http=require(<span class="hljs-string">&quot;http&quot;</span>);<br>var server=http.creat<span class="hljs-constructor">Server(<span class="hljs-params">function</span>(<span class="hljs-params">req</span>,<span class="hljs-params">res</span>)</span>&#123;<br>    res.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Content-Type&quot;</span>,<span class="hljs-string">&quot;text/html;charset=UTF8&quot;</span>)</span>;<br>    res.<span class="hljs-keyword">end</span>(<span class="hljs-string">&quot;first http server end&quot;</span>);<br>&#125;)<br><span class="hljs-comment">//监听3000端口</span><br>server.listen(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p>此时可以浏览器访问<a href="http://127.0.0.1:3000/">http://127.0.0.1:3000/</a></p><h2 id="3-fs模块的简单使用"><a href="#3-fs模块的简单使用" class="headerlink" title="3.fs模块的简单使用"></a>3.fs模块的简单使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">var</span> fs=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> server=http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>&#123;<br>    res.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>,<span class="hljs-string">&quot;text/html;charset=UTF8&quot;</span>);<br>    fs.readFile(<span class="hljs-string">&quot;./Hello.html&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err,data</span>)</span>&#123;<br>        res.write(data);<br>        res.end(<span class="hljs-string">&quot;first http server end&quot;</span>);<br>    &#125;)<br><br>&#125;)<br><span class="hljs-comment">//监听3000端口</span><br>server.listen(<span class="hljs-number">3000</span>)<br><br><span class="hljs-comment">// 终端打印如下信息</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server running at http://127.0.0.1:3000/&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="4-路由的简单设计"><a href="#4-路由的简单设计" class="headerlink" title="4.路由的简单设计"></a>4.路由的简单设计</h2><p>req.url可以得到形如/user/zhang/update的路由<br>通过字符串的match方法来匹配正则表达式从而获得各信息</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> http=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">var</span> fs=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">var</span> server=http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>&#123;<br>    res.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>,<span class="hljs-string">&quot;text/html;charset=UTF8&quot;</span>);<br>    <br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">url</span>=req.url;<br>    <span class="hljs-keyword">var</span> arr=<span class="hljs-built_in">url</span>.match(<span class="hljs-regexp">/\/user\/(.+)\/(.+)$/</span>);<br>    <span class="hljs-keyword">if</span> (!arr)&#123;<br>        res.end(<span class="hljs-string">&quot;no pages!&quot;</span>);<br>    &#125;<span class="hljs-title">else</span> &#123;<br>        <span class="hljs-keyword">var</span> $<span class="hljs-number">1</span>=arr[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">var</span> $<span class="hljs-number">2</span>=arr[<span class="hljs-number">2</span>];<br>        res.write(<span class="hljs-string">&quot;&lt;h2&gt;&quot;</span>+$<span class="hljs-number">1</span>+<span class="hljs-string">&quot;&lt;/h2&gt;&quot;</span>);<br>        res.write(<span class="hljs-string">&quot;&lt;h2&gt;&quot;</span>+$<span class="hljs-number">2</span>+<span class="hljs-string">&quot;&lt;/h2&gt;&quot;</span>);<br>        res.end();<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//监听3000端口</span><br>server.listen(<span class="hljs-number">3000</span>)<br><br></code></pre></td></tr></table></figure><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type:"></a>Content-Type:</h3><pre><code>res.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=UTF8&quot;);</code></pre><ul><li>text/html:html格式</li><li>text/plain:纯文本格式</li><li>text/xml:xml格式</li><li>image/gif:gif图片格式</li><li>image/jpg:jpg图片格式</li><li>image/png:png图片格式</li></ul><h2 id="5-模块"><a href="#5-模块" class="headerlink" title="5.模块"></a>5.模块</h2><p>当一个js文件可以独立完成一个功能时，这个文件就是一个模块；<br>当多个文件共同完成一个功能时，这些文件就是一个模块<br>模块module</p><h3 id="HTML的多文件引用"><a href="#HTML的多文件引用" class="headerlink" title="HTML的多文件引用"></a>HTML的多文件引用</h3><p>多个js文件公用一个html宿主时，变量都在同一个作用域，因为变量是window的对象</p><h3 id="node-js的多文件引用"><a href="#node-js的多文件引用" class="headerlink" title="node.js的多文件引用"></a>node.js的多文件引用</h3><ul><li>require()在引用文件的同时也在执行该文件</li><li>node.js文件中的变量作用域天生隔离，因为没有window对象</li><li>各node.js文件间需要自动暴露</li></ul><h3 id="exports命令"><a href="#exports命令" class="headerlink" title="exports命令"></a>exports命令</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span>=<span class="hljs-number">100</span>;<br><span class="hljs-keyword">export</span>.<span class="hljs-built_in">num</span>=<span class="hljs-built_in">num</span>;<br></code></pre></td></tr></table></figure><p>另外一个js文件再使用require引入该文件就可以使用num变量了</p><h3 id="exports的命名空间"><a href="#exports的命名空间" class="headerlink" title="exports的命名空间"></a>exports的命名空间</h3><p>每次require返回的是被引用文件中exports所暴露的属性或方法组装成的对象</p><h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h3><p>当一个js文件只想暴露一个属性时，一般是暴露构造函数<br>其他的属性或方法赋值给构造函数的属性<br>可以通过new People.People()可以new对象</p><h3 id="文件夹的使用"><a href="#文件夹的使用" class="headerlink" title="文件夹的使用"></a>文件夹的使用</h3><p>require的参数没有.js后缀时就默认在引用一个文件夹<br>require的参数是一个文件夹时，会把文件夹的每一个文件封装到一个对象里返回，<br>var result=require(“./result”);<br>result.file1.area</p><h3 id="node-modules文件夹"><a href="#node-modules文件夹" class="headerlink" title="node_modules文件夹"></a>node_modules文件夹</h3><p>如果文件夹内部存放了node_modules文件夹，require的参数就不需要./开头了，只要require的参数不是./起头就是引入node_modules文件夹内部的文件</p><h2 id="6-npm的基本使用"><a href="#6-npm的基本使用" class="headerlink" title="6.npm的基本使用"></a>6.npm的基本使用</h2><ul><li>npm -v 查看npm的版本信息</li><li>npm是一个包管理器，是一个世界范围的模块分享社区，我们可以使用这个社区里别人开发的模块。</li><li><a href="http://www.npmjs.com可以直接搜索需要的模块，然后使用命令安装，如：npm">www.npmjs.com可以直接搜索需要的模块，然后使用命令安装，如：npm</a> install nzh，nzh为模块名</li></ul><h3 id="npm的身份证和依赖"><a href="#npm的身份证和依赖" class="headerlink" title="npm的身份证和依赖"></a>npm的身份证和依赖</h3><ul><li>依赖就是node_modules里的模块，身份证是packge.json，里面会有一些包名、关键字等信息，使用npm init可以初始化然后设置身份证</li><li>在有了身份证后，再添加依赖时要有–save选项，如npm install –save nzh 这样做是为了便于包的传播安装，别人拿到package.json后就可以直接npm install来安装所有package.json中的依赖。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>编程语言</category>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>入门</tag>
      
      <tag>nodejs</tag>
      
      <tag>服务器</tag>
      
      <tag>路由</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础知识</title>
    <link href="/Pages/2021/01/09/2021-01-09-python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%B7%E5%A4%87%E5%85%B6%E4%BB%96%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bpython)/"/>
    <url>/Pages/2021/01/09/2021-01-09-python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%B7%E5%A4%87%E5%85%B6%E4%BB%96%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bpython)/</url>
    
    <content type="html"><![CDATA[<p>==前言：本文适合具备C、java等语言基础的python初学者==</p><h1 id="一、python简介"><a href="#一、python简介" class="headerlink" title="一、python简介"></a>一、python简介</h1><h2 id="1-优势与特点："><a href="#1-优势与特点：" class="headerlink" title="1.优势与特点："></a>1.优势与特点：</h2><ol><li>代码开源；</li><li>代码像自然语言一样易懂；</li><li>适用于短周期开发的日常任务；</li><li>代码优雅、简单、明确；</li><li>代码量少；</li><li>面向对象；</li><li>有强大的标准库和第三方模块；</li><li>可扩展性好，能很方便的调用其他语言；</li></ol><h2 id="2-开发环境"><a href="#2-开发环境" class="headerlink" title="2.开发环境"></a>2.开发环境</h2><p>python的源程序是特殊格式的文本文件，所有的文本编辑器都可以直接编辑python代码，python是解释执行的，目前最常用的解释器是python2和python3。<br>在linux下运行python十分便捷，编写好后，中端直接输入python+filename即可。</p><p><img src="https://img-blog.csdnimg.cn/20210109111436920.png" alt="执行python程序"></p><p>也可以直接输入python，交互式的执行python语句。</p><p><img src="https://img-blog.csdnimg.cn/2021010911160666.png" alt="交互式python"></p><p>不过，最常用的IDE还是pycharm，之后的演示均转移到pycharm上。</p><p><img src="https://img-blog.csdnimg.cn/20210109112022753.png" alt="pycharm"></p><h1 id="二、python基本数据类型"><a href="#二、python基本数据类型" class="headerlink" title="二、python基本数据类型"></a>二、python基本数据类型</h1><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。变量的类型不会显示的声明</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#注释：python中使用#来表示单行注释</span><br><br><span class="hljs-attr">num1</span>=<span class="hljs-number">100</span>    <span class="hljs-comment">#整形变量</span><br><span class="hljs-attr">num2</span>=<span class="hljs-number">100.0</span><span class="hljs-comment">#浮点型</span><br><span class="hljs-attr">numString</span>=<span class="hljs-string">&quot;123&quot;</span><span class="hljs-comment">#字符串</span><br></code></pre></td></tr></table></figure><h2 id="标准数据类型："><a href="#标准数据类型：" class="headerlink" title="标准数据类型："></a>标准数据类型：</h2><ul><li>Number（数字）<ul><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul></li></ul><h3 id="1-Number（数字）"><a href="#1-Number（数字）" class="headerlink" title="1.Number（数字）"></a>1.Number（数字）</h3><p>Python3 支持 int、float、bool、complex（复数）</p><pre><code>a, b, c, d = 20, 5.5, True, 4+3j</code></pre><p><img src="https://img-blog.csdnimg.cn/20210109115524597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="自动分派数据类型"></p><p>数值运算：</p><pre><code>1+1    #加法    2.1-1    #减法2.1*2    #乘法2/4     #除法7//4    #整除，此结果为17%4    #取余2**10    #n次方运算，此结果为1024</code></pre><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>Python中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \ 转义特殊字符。</p><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><pre><code>str=&quot;hellopython&quot;print(str[0:4])print(str[1:-1])print(str[2:])print(str+&quot;hellostring&quot;)</code></pre><p>运行结果：</p><pre><code>hellellopythollopythonhellopythonhellostring</code></pre><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号 [] 之间、用逗号分隔开的元素列表。</p><p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><pre><code>onelist = [&quot;abc&quot; , 12, 1.2 , True ]print(onelist[0:2])print(onelist[1:-1])print(onelist[2:])print(onelist + onelist[0:2])</code></pre><p>运行结果如下</p><pre><code>[&#39;abc&#39;, 12][12, 1.2][1.2, True][&#39;abc&#39;, 12, 1.2, True, &#39;abc&#39;, 12]</code></pre><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p><pre><code>tuple = ( &#39;abcd&#39;, 786 , 2.23, &#39;runoob&#39;, 70.2  )tinytuple = (123, &#39;runoob&#39;)print (tuple)             # 输出完整元组print (tuple[0])          # 输出元组的第一个元素print (tuple[1:3])        # 输出从第二个元素开始到第三个元素print (tuple[2:])         # 输出从第三个元素开始的所有元素print (tinytuple * 2)     # 输出两次元组print (tuple + tinytuple) # 连接元组</code></pre><p>运行结果：</p><pre><code>(&#39;abcd&#39;, 786, 2.23, &#39;runoob&#39;, 70.2)abcd(786, 2.23)(2.23, &#39;runoob&#39;, 70.2)(123, &#39;runoob&#39;, 123, &#39;runoob&#39;)(&#39;abcd&#39;, 786, 2.23, &#39;runoob&#39;, 70.2, 123, &#39;runoob&#39;)</code></pre><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>里面的元素不允许重复，重复元素会被自动删除<br>可以使用大括号 { } 或者 set() 函数创建集合</p><pre><code>a = &#123;&quot;csdn&quot;,&quot;zhihu&quot;,&quot;csdn&quot;&#125;b = &#123;&quot;baidu&quot;,&quot;tencent&quot;,&quot;csdn&quot;&#125;print(a)print(a-b)    #a集合减去a,b的交集print(a|b)    #a，b集合的并集print(a&amp;b)    #a，b集合的交集print(a^b)    #a，b两集合中各自不同的元素组成的集合</code></pre><p>运行结果如下：</p><pre><code>&#123;&#39;zhihu&#39;, &#39;csdn&#39;&#125;&#123;&#39;zhihu&#39;&#125;&#123;&#39;csdn&#39;, &#39;baidu&#39;, &#39;tencent&#39;, &#39;zhihu&#39;&#125;&#123;&#39;csdn&#39;&#125;&#123;&#39;baidu&#39;, &#39;zhihu&#39;, &#39;tencent&#39;&#125;</code></pre><h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p>字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。</p><pre><code>dict = &#123;&#125;    #空字典dict[&#39;one&#39;] = &quot;1 - CSDN&quot;dict[2]     = &quot;2 - csdn&quot;tinydict = &#123;&#39;name&#39;: &#39;csdn&#39;,&#39;code&#39;:1, &#39;site&#39;: &#39;www.csdn.net&#39;&#125;print (dict[&#39;one&#39;])       # 输出键为 &#39;one&#39; 的值print (dict[2])           # 输出键为 2 的值print (tinydict)          # 输出完整的字典print (tinydict.keys())   # 输出所有键print (tinydict.values()) # 输出所有值</code></pre><p>运行结果：</p><pre><code>1 - CSDN2 - csdn&#123;&#39;name&#39;: &#39;csdn&#39;, &#39;code&#39;: 1, &#39;site&#39;: &#39;www.csdn.net&#39;&#125;dict_keys([&#39;name&#39;, &#39;code&#39;, &#39;site&#39;])dict_values([&#39;csdn&#39;, 1, &#39;www.csdn.net&#39;])</code></pre><h1 id="三、逻辑控制"><a href="#三、逻辑控制" class="headerlink" title="三、逻辑控制"></a>三、逻辑控制</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><pre><code>if condition_1:    statement_block_1elif condition_2:    statement_block_2else:    statement_block_3</code></pre><p>注意if后面不需要()来包裹条件，不需要{}来包裹语句，注意要加<code>:</code>，注意控制缩进来代替{}。</p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code>sum = 0counter = 1while counter &lt;= 100:    sum = sum + counter    counter += 1</code></pre><p>与C语言、java的while循环大同小异</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code>#从容器中逐个取元素至x中，直至取完languages = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;]for x in languages:    print (x)</code></pre><h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>for循环常与range()函数搭配使用，range()可以生成一个数字序列</p><pre><code>for i in range(5):    print(i)for i in range(5,9):    print(i)for i in range(0,10,3):    print(i)</code></pre><p>生成的序列分别是：</p><pre><code>0,1,2,3,45,6,7,80,3,6,9</code></pre><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><p>break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。</p><p>continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p><h1 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h1><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p><p>自定义函数：</p><pre><code>def max(a,b):    if a&gt;b:        return a    else:        return b</code></pre><p>注意一定控制好缩进，缩进的对齐代替了其他语言的{}，另外函数结束一定有<code>return</code>语句，<code>return</code>后面不跟值表示没有返回值。</p><p>注意定义好函数后只有调用函数，函数代码才会执行，调用方式例如：<code>c=max(3.14,3.15)</code></p><h1 id="五、输入输出"><a href="#五、输入输出" class="headerlink" title="五、输入输出"></a>五、输入输出</h1><pre><code>str = input(&quot;输入提示，例如请输入：&quot;)print(str)</code></pre><h1 id="六、类和对象"><a href="#六、类和对象" class="headerlink" title="六、类和对象"></a>六、类和对象</h1><pre><code>class Student:    def __init__(self,na):        self.name=na    name=&quot;zhangsan&quot;    def getName(self):        return self.name</code></pre><p>上面设计了一个Student类，其中<code>__init()__</code>是构造函数，<code>self</code>是创建对象是自身的引用，相当于java中的<code>this</code>,所有类的方法都需要包含该形参。<br>私有属性或方法只需以双下划线开头即可<br>如<code>__name</code>和<code>def __getName(self)</code></p><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><pre><code>stu=Student(&quot;李四&quot;)</code></pre><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>在定义类时只需在<code>()</code>中写出需要继承的父类即可，可以继承多个父类，如：</p><pre><code>class Student(People):    #类的属性方法等class A(B,C):    #类的属性方法</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>编程语言</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>入门</tag>
      
      <tag>python</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下的C语言入门（以ubuntu为例）</title>
    <link href="/Pages/2020/12/17/2020-12-17-Linux%E4%B8%8B%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%88ubuntu%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
    <url>/Pages/2020/12/17/2020-12-17-Linux%E4%B8%8B%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%88ubuntu%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编辑器vi-vim"><a href="#一、编辑器vi-vim" class="headerlink" title="一、编辑器vi(vim)"></a>一、编辑器vi(vim)</h1><p>vi是最常用的文本编辑器，我们可以使用它来编写C语言代码。</p><pre><code>vi hello.c    //编辑一个名为hello.c的文件</code></pre><p>进入vi编辑器后，有两种模式：命令模式、插入模式。<br>一进来就时命令模式，输入i在当前光标处开始插入字符，可以用上下左右箭头控制输入。摁<code>esc</code>键可回到命令模式，下面介绍命令模式下几种常用的命令：</p><pre><code>3 dd    //将光标所在行往下共3行代码剪切3 yy    //将光标所在行往下共3行代码复制p    //粘贴:set nu    //显示行号:sp filename    //新建一个文件并打开编辑窗口:wq    //保存并退出:q    //退出:q!    //强制退出</code></pre><h1 id="二、编译命令"><a href="#二、编译命令" class="headerlink" title="二、编译命令"></a>二、编译命令</h1><pre><code>//将hello.c编译，编译输出文件名为hello.outgcc hello.c -o hello.out    </code></pre><p><img src="https://img-blog.csdnimg.cn/20201217110149954.png" alt="编译"></p><p>编译完成后，就可以运行hello.out文件：</p><pre><code>./hello.out</code></pre><p><img src="https://img-blog.csdnimg.cn/20201217110411114.png" alt="运行"></p><h1 id="三、使用gdb调试代码"><a href="#三、使用gdb调试代码" class="headerlink" title="三、使用gdb调试代码"></a>三、使用gdb调试代码</h1><p>注意要使用gdb来调试代码，在我们编译的时候，编译命令要多加一个参数<code>-g</code>，格式如下：</p><pre><code>gcc hello.c -o hello.out -g</code></pre><p>然后就可以对程序调试了：</p><pre><code>gdb hello.out</code></pre><p>然后进入到调试环境（gdb）,我们下面介绍一些基本的调试命令：</p><pre><code>l    //显示源代码start    //开始调试，可以运行到下一个断点break 6    //在第六行添加一个断点break max    //在函数max的起始位置添加断点info break    //显示所有断点delete numofBreak    //删除编号为numofBreak的断点n    //执行一行语句，注意不进入函数内部s    //执行一行语句，遇到函数会进入函数内部finish    //执行完当前函数p a    //查看变量a的值p &amp;a    //查看变量a的地址bt    //查看函数栈，可以看到函数序号f 1    //切换到序号为的1的函数q    //退出gdb调试</code></pre><h1 id="四、多文件编译及makefile的使用"><a href="#四、多文件编译及makefile的使用" class="headerlink" title="四、多文件编译及makefile的使用"></a>四、多文件编译及makefile的使用</h1><p>命令格式：</p><pre><code>gcc hello1.c hello2.c hello12.c -o hello.out -g</code></pre><p>在hello1.c,hello2.c,hello12.c里的函数可以相互调用，当我们的源文件有很多很多时，每次都手动输入这些命令麻烦且容易出错，因此我们要使用make工具来管理这些编译命令，以达到快捷编译的效果。<br>使用方式：新建一个makefile文件，然后在里面编写内容：</p><pre><code>/*格式： *    outputfilename:file1 file2 file3 *    |&lt;- tab-&gt;| gcc file1 file2 file3 -o outputfilename -g *解释： *    第一行是代表编译生成outputfilename文件所需要那些文件 *    第二行是编译命令，注意其前面一定要有一个tab *注意： *    在第一行中如果存在非.c的文件， *    需要下面按着格式写明该文件的编译 */hello.out:hello1.o hello2.o hello12.c        gcc hello1.o hello2.o hello12.c -o hello.out -g        hello1.o:hello1.c        gcc hello1.c -o hello1.o -g        hello2.0:hello2.c        gcc hello2.c -o hello2.o -g</code></pre><p>当makefile文件编写保存好之后，只需输入<code>make</code>命令就可快捷地进行编译。</p><h1 id="五、拓展知识"><a href="#五、拓展知识" class="headerlink" title="五、拓展知识"></a>五、拓展知识</h1><p>linux下的命令也是一个个C语言的小程序，执行命令时会调用相应的程序</p><h2 id="1-main-的真实写法应为："><a href="#1-main-的真实写法应为：" class="headerlink" title="1.main()的真实写法应为："></a>1.main()的真实写法应为：</h2><pre><code>/*     *    argv代表argc数组的长度，argc里面存储的是终端输入的命令， *    每一个空格即增加一个长度，比如命令ls -l，该命令就会 *    存入argc数组中，而argv为2 */int main(int argv,char* argc[])</code></pre><h2 id="2-main函数中的return值代表该运行的成功与否"><a href="#2-main函数中的return值代表该运行的成功与否" class="headerlink" title="2.main函数中的return值代表该运行的成功与否"></a>2.main函数中的return值代表该运行的成功与否</h2><pre><code>return 0;//运行正常return 110;//返回110号错误</code></pre><h2 id="3-两条命令之间可以用-amp-amp-来连接"><a href="#3-两条命令之间可以用-amp-amp-来连接" class="headerlink" title="3.两条命令之间可以用&amp;&amp;来连接"></a>3.两条命令之间可以用<code>&amp;&amp;</code>来连接</h2><p>第二条命令则仅在第一条命令执行成功的情况下执行。</p><h2 id="4-linux将所有的资源或设备均看作一个文件"><a href="#4-linux将所有的资源或设备均看作一个文件" class="headerlink" title="4.linux将所有的资源或设备均看作一个文件"></a>4.linux将所有的资源或设备均看作一个文件</h2><p>比如标准输出输入流、错误流分别对应<code>stdout</code>、<code>stdin</code>、<code>stderr</code>三个文件，C语言中一旦引入stdio库就引入这三个文件。</p><pre><code>//printf(&quot;please input&quot;);fprintf(stdout,&quot;please input&quot;);fscanf(stdin,&quot;%d&quot;,&amp;a);fprintf(stderr,&quot;errormessage&quot;);/*     *    注意上面的代码中的stdout,stdin,stderr *    可以用任何其他文件替代 */</code></pre><h2 id="5-重定向"><a href="#5-重定向" class="headerlink" title="5.重定向"></a>5.重定向</h2><p><code>./a.out 1&gt;&gt; a.txt</code><br>上面的命令可以将a.out的正确的输出流stdout里的内容输出到a.txt中，<code>&gt;&gt;</code>是追加形式，<code>&gt;</code>是覆盖的形式</p><p><code>./a.out &lt; input.txt</code><br>从input.txt中读取输入流</p><p><code>./a.out 1&gt; a.txt 2&gt; b.txt &lt;input.txt</code><br>表示正确的输出流输出到a.txt，错误的输出流输出到b.txt，并从input.txt中读取输入流</p><h2 id="6-管道"><a href="#6-管道" class="headerlink" title="6.管道"></a>6.管道</h2><p><code>ls /etc/ |grep ab</code><br>命令的意思是将<code>ls /etc/</code>命令的输出当作<code>grep ab</code>命令的输入，这样就可以列出/etc/目录下所有包含ab的文件或目录</p><p><code>ps -e | grep ssh</code><br><code>ps</code>是列出当前运行的进程，上述命令即为列出包含ssh的内容</p><h2 id="7-操作系统对内存的管理"><a href="#7-操作系统对内存的管理" class="headerlink" title="7.操作系统对内存的管理"></a>7.操作系统对内存的管理</h2><p><img src="https://img-blog.csdnimg.cn/20201217175313937.png" alt="操作系统内存示意"></p><p>注意：其中栈底是高地址，栈顶是低地址。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>学习笔记</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>C语言</tag>
      
      <tag>入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>王亡於江上之周昭王姬瑕</title>
    <link href="/Pages/2020/12/15/2020-12-15-%E3%80%8A%E7%8E%8B%E4%BA%A1%E6%96%BC%E6%B1%9F%E4%B8%8A%E3%80%8B%E4%B9%8B%E5%91%A8%E6%98%AD%E7%8E%8B%E5%A7%AC%E7%91%95/"/>
    <url>/Pages/2020/12/15/2020-12-15-%E3%80%8A%E7%8E%8B%E4%BA%A1%E6%96%BC%E6%B1%9F%E4%B8%8A%E3%80%8B%E4%B9%8B%E5%91%A8%E6%98%AD%E7%8E%8B%E5%A7%AC%E7%91%95/</url>
    
    <content type="html"><![CDATA[<h1 id="《王亡於江上》之周昭王姬瑕"><a href="#《王亡於江上》之周昭王姬瑕" class="headerlink" title="《王亡於江上》之周昭王姬瑕"></a>《王亡於江上》之周昭王姬瑕</h1><blockquote><p>我乃天子姬瑕，是这天下诸侯唯一的王，但是此时我命不久矣，因为我现在溺水了，已经无法呼吸了，我能做的，只有回忆。</p></blockquote><p><code>我自五岁即位，我母后是莘国公主，我有很多哥哥，还有两个弟弟，但父王却立我为太子，母后告诉我，我是父王的第一个嫡子。母后告诉我，她并不喜欢父王，但是大舅父逼他嫁给父王，母后也不敢不从。我即位后的第十一年，母后去世了，她给了我一对婚服，那是外公临走时给母后的，母后说外公很痛爱她，那婚服是外公准备好给她的。现在母后又把这对婚服给了我，希望我能和我心爱的人穿上。 </code></p><p><code>我自幼执政，宗室的诸公和中原的公侯老是跟我说这不能做，那不符合礼数。我不喜欢听这些，我喜欢和我的小伙伴莘由靡一起玩，他是外公的孙子，他也陪我在宫中长大，不过他是质子的身份。在我即位的第十三年的夏天，莘公去世了，我让莘由靡回国接替莘国。后来他成莘公了，我在朝堂上把事情就都交给他。</code></p><p><code>随着年龄的增长，就经常有宗室长者劝我立后立太子了，我不喜欢，我想实现母后的遗愿：和心爱的人穿婚服。</code></p><p><code>在我执政的第十六年，我还是立了后，虽然不喜欢但是还是生下了一子一女。</code></p><p><code>作为一个王，我很鄙视南方的蛮夷，我为了不闲着，我就经常带着诸侯去征讨南方。</code></p><p><code>我即位的第十八年秋天，趁着秋收有粮，我带着诸侯去讨伐楚国，那次楚国大败，莘由靡立下了大功。不过，那年楚国的国君战后病死了，我还是有点吃惊的，因为按书上写，战也是遵循礼的，战胜即归，可收地可收贡品，我却不曾想要楚君的命，但我不必在意，因为我是天下的王。</code></p><p><code>我即位的第十九年春天，楚国新君来朝拜我，想要我退还失地。若是平常，还就还了，我堂堂天子，不必和你一个子爵争，但我想把这块地赐给莘由靡。莘由靡知晓了坚持不要，并且让我接见楚君。于是我接见了楚君，接见的那天晚上，无意中我爱上一个女子，叫芈婉，她真的很美，月光打在她的身上，她宛如嫦娥一般，但又如此的自然，如此的特别，我想和她穿上母后留下的婚服。不巧的是，她竟然是熊黵的妹妹，她的子父熊艾刚去世。</code></p><p><code>芈婉说她喜欢我，我问她是不是喜欢我的王位喜欢我的权力。她说，如果可以，她只想做个平民，连楚国公主也不要做。她和我好像，我也想做个平民。于是我把她留宿宫中了，她在宫里住了一个多月，我说我要封她为后。但是宗室和中原的公侯都轮番劝谏，甚至说芈婉是妖女，要杀她。这个时候，熊黵说按照周礼，芈婉如要嫁入周室应先回楚国祭拜刚亡故的子父。</code></p><p><code>芈婉也说，她确实应该回去一趟。我只好应允。</code></p><p><code>离别之际，我心中总感觉此去一别，遥遥无期，我和她约定，如果熊黵不送她回来，就在九月初吉，到淮水源头，我去接她。她应允了，我把时间地点以及一些情话写在丝帛上交给她：</code></p><blockquote><p>有美一人，轻扬婉兮。<br>好风南来，轻摇纨扇。<br>粉腮红润，秀牟馨忪。<br>回忆万万，一笑命远。</p></blockquote><p><code>她说，她祭拜完子父肯定会回来的。</code></p><p><code>到了八月，熊黵果然还没有送芈婉回来，我布告诸侯，会猎南巡，准备前往淮水接回芈婉。</code></p><p><code>八月既死霸，我和蔡叔还有莘由靡一起南巡狩猎。莘由靡知道我的心思，一路忧心忡忡的。</code></p><p><code>到了淮水北岸，我们在这里驻营数日，终于派过岸的小侍卫打探到芈婉的消息了。我和莘由靡乘小船过江，见到芈婉，我真的很开心，当时我就只想马上带她回周王畿。但是楚兵围过来了，芈婉一个人留下说她可以劝退楚兵，我被莘由靡拖走了，也不得不走，但走了也没用。</code></p><p><code>我们原路返回，正遇上蔡叔带着三两侍从渡江过来了。</code></p><p><code>我们一起来到江边，却发现小船都被弄坏了。情急之下，我和蔡叔带着两个随从沿江往东面找船，莘由靡往西找船。</code></p><p><code>我和蔡叔找到一艘小船，我们急于渡江，也不识得这是什么材质的船，便匆匆上船。渡江未至一半，船开始渗水，最后我们在水里挣扎，我踩着两个侍从想多呼吸一口气，却被蔡叔往下摁了下去。</code></p><p><code>我吸进了很多水，我想咳又咳不动，我无法呼吸了，在这生命的最后一刻，我只能回忆。</code></p><blockquote><p>我不是个合格的君王，在临死之际，我不关心江山社稷该如何传承，我只想念两个女人：我的母后和我的芈婉。</p></blockquote><p>==故事纯属虚构，了解更多请阅读《王亡於江上》故事主线和其他人物篇==</p>]]></content>
    
    
    <categories>
      
      <category>周时故事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>历史</tag>
      
      <tag>周昭王</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>王亡於江上</title>
    <link href="/Pages/2020/12/15/2020-12-15-%E3%80%8A%E7%8E%8B%E4%BA%A1%E6%96%BC%E6%B1%9F%E4%B8%8A%E3%80%8B/"/>
    <url>/Pages/2020/12/15/2020-12-15-%E3%80%8A%E7%8E%8B%E4%BA%A1%E6%96%BC%E6%B1%9F%E4%B8%8A%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="王亡於江上"><a href="#王亡於江上" class="headerlink" title="王亡於江上"></a>王亡於江上</h1><blockquote><p>昭王之时，王道微缺。<br>昭王南巡狩不返，卒於江上。<br>其卒不赴告，讳之也。<br>–《史记》</p></blockquote><h2 id="故事概要"><a href="#故事概要" class="headerlink" title="故事概要"></a>故事概要</h2><p><em>昭王十七年，伐楚国，莘公立功，不讨封赏。</em><br><em>昭王十八年春，楚新君熊黵即位，入朝献地联姻。昭王私见楚女，甚是喜欢，赐胙肉，加封楚君。熊黵以行楚礼为由，请带楚女先行归国；因担心昭王留恋私情，莘公领群臣力谏昭王。昭王允之，亲自送行。</em><br><em>昭王十八年九月初吉，昭王布告诸侯，将南巡淮河下游，莘公、蔡叔等同往。同时，楚女芈婉向其兄熊黵请往北方以采雪莲，与昭王私会淮河上游。巴国质楚公子，盗取其表兄熊黵兵符，领重兵包围昭王。芈婉回楚营退兵，昭王回营整队，不想回营途中，船只为楚人变更，淹死江中，莘由靡打捞尸体秘不发丧，回周后拥太子满即位。</em></p><h2 id="详细故事"><a href="#详细故事" class="headerlink" title="详细故事"></a>详细故事</h2><p><code>武王伐纣，武王十五年，成王即位，成王二十又一年传康王，康王在位二十五年，三代政绩卓著，诸侯归心，礼乐严明，周室兴盛，史称“成康之治”，康王崩，昭王即位，昭王行事古怪，好战，多次征伐南方，不受平民和边境诸侯爱戴，自此王道始缺。</code></p><p><code>昭王十六年，率诸侯伐楚国，楚国大败，楚君熊艾战后病故，其子熊黵继承其子爵，领楚国，为楚国第三代国君。 昭王十七年，春，熊黵前往畿进贡请胙，携带金玉、奴隶、侍女献给昭王，同行的还有其妹妹芈婉，芈婉国色天香，美丽动人，熊黵欲求姻于天子，来讨回去年战败失地。</code></p><p><code>昭王这边准备将去年赢得的楚地赏赐给常伴自己左右的莘国国君莘由靡，故迟迟不接见熊黵。莘由靡劝谏昭王接见熊黵，昭王便让熊黵晚上进殿朝贡。熊黵提前用银钱买通宫中寺人，安排了芈婉和昭王偶遇，昭王对芈婉一见倾心，欲封芈婉为后，并将失地还与楚国。在朝堂之上力压百官，要求封芈婉为后，熊黵见周室朝堂如此反对，担心客死周王畿，请求先带芈婉回楚国准备嫁娶连日赶回楚国。</code></p><p><code>熊黵回楚后，巴国质楚公子和熊黵密谋设计欲杀昭王。 而芈婉，也对昭王恋恋不忘，竟然在离开周王畿时约定让昭王九月初吉到楚国境内淮水源头相会。而巴涂暗恋芈婉，在约芈婉外出游玩中无意发现此事，立即告诉熊黵。</code></p><p><code>熊黵和巴涂两人想借此机会将昭王杀死，以报周室多年欺压之仇。 八月，昭王果然布告诸侯，南巡狩猎。蔡叔随行，莘由靡为昭王驾车，一路狩猎至楚国边境。</code></p><p><code>芈婉与此同时也谎称采摘千年水莲前往淮水源头，私会昭王。熊黵却派巴涂领兵尾随。 昭王命蔡叔驻军在淮水北面，自己与莘由靡驾小船到淮水南面接应芈婉。</code></p><p><code>见到芈婉后却被楚兵追杀，芈婉留下前去劝退楚兵，昭王和莘由靡原路返回。到江边后发现蔡叔也渡江过来，但三人回江边后，船都被损毁了。昭王蔡叔沿江往东寻找船只，莘由靡沿江往西寻找船只。</code></p><p><code>芈婉这边在与巴涂纠缠，而后巴涂和芈婉讲明事情原委，芈婉知道真相后跳入江中，被巴涂救起带回楚国。原来熊黵不想担负弑君的罪名，害怕被周室征讨，便派二三农夫到淮水边上损坏船只，并在江边放置许多胶船。</code></p><p><code>昭王这边却急于渡江，乘坐胶船淹死在江中。莘由靡水性好，游回了淮水北侧，在江边打捞起昭王和蔡叔的尸体。莘由靡害怕消息传回周王畿会有人作乱，于是密不发丧。</code></p><p><code>昭王十九年，太子满即位，是为穆王，诰命天下诸侯朝贡。</code></p><p><code>芈婉听闻周王畿传来新王即位的诰书，半月不食而亡。</code></p><h2 id="人物概要"><a href="#人物概要" class="headerlink" title="人物概要"></a>人物概要</h2><p><em>人物故事可详见《王亡於江上》之周昭王姬瑕、《王亡於江上》之楚国君熊黵、《王亡於江上》之莘由靡、《王亡於江上》之芈婉，故事更多，情节更丰富哦！</em></p><p><code>昭王：姬瑕，周室第四代天子，多次南征，称南方诸国为蛮夷；喜欢芈婉，南巡私会芈婉，情急之下淹死淮水之中。</code></p><p><code>熊黵：楚国第三代君主，痛恨天子对楚国有偏见。芈婉的亲哥哥，用芈婉诱惑昭王，并设计成功害死了昭王。</code></p><p><code>莘由靡：周王畿旁边的莘国国君，常年侍奉昭王，同昭王一起在宫中长大，在昭王征伐楚国时，立下功劳。陪昭王一起南巡，昭王溺死后，密不发丧，带昭王尸体回周王畿后，拥太子满即位。</code></p><p><code>芈婉：熊黵妹妹，随兄长一起进贡朝拜昭王，在熊黵的促使下，与昭王相见，并与昭王一见倾心。与昭王约定在昭王十九年九月相会淮水，却不小心被巴涂偷偷知晓并报告给了熊黵。九月前往私会昭王，知道哥哥的阴谋后，跳江未遂。回楚国后，绝食而亡。</code></p><p>==本文及其附属文章故事均为虚构，切莫当作真实历史故事。昭王在历史上确有此人，但《史记》仅仅只用一句话描述了这位溺水君王的一生。==</p>]]></content>
    
    
    <categories>
      
      <category>周时故事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>历史</tag>
      
      <tag>周昭王</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令以及远程仓库github的使用</title>
    <link href="/Pages/2020/12/10/2020-12-10-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88linux%E4%BB%A5ubuntu%E4%B8%BA%E4%BE%8B%E5%AD%90%EF%BC%89--%E5%88%9D%E5%AD%A6%E7%89%88/"/>
    <url>/Pages/2020/12/10/2020-12-10-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88linux%E4%BB%A5ubuntu%E4%B8%BA%E4%BE%8B%E5%AD%90%EF%BC%89--%E5%88%9D%E5%AD%A6%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="git常用命令——初学版"><a href="#git常用命令——初学版" class="headerlink" title="git常用命令——初学版"></a>git常用命令——初学版</h1><p>以ubuntu为例。</p><h2 id="一、安装和配置git"><a href="#一、安装和配置git" class="headerlink" title="一、安装和配置git"></a>一、安装和配置git</h2><h3 id="1-安装命令如下：-sudo-apt-get-install-git"><a href="#1-安装命令如下：-sudo-apt-get-install-git" class="headerlink" title="1.安装命令如下： sudo apt-get install git"></a>1.安装命令如下： sudo apt-get install git</h3><pre><code> sudo apt-get install git </code></pre><h3 id="2-git-查看是否安装"><a href="#2-git-查看是否安装" class="headerlink" title="2.git 查看是否安装"></a>2.git 查看是否安装</h3><pre><code> git</code></pre><h3 id="3-git-init-初始化仓库"><a href="#3-git-init-初始化仓库" class="headerlink" title="3.git init 初始化仓库"></a>3.git init 初始化仓库</h3><pre><code>git init</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210105515538.png" alt="初始化git仓库"></p><h2 id="二、git操作"><a href="#二、git操作" class="headerlink" title="二、git操作"></a>二、git操作</h2><h3 id="1-git-add-file1-file2-file3-file4-把修改过的文件file1234都添加到暂存区"><a href="#1-git-add-file1-file2-file3-file4-把修改过的文件file1234都添加到暂存区" class="headerlink" title="1.git add file1 file2 file3 file4 把修改过的文件file1234都添加到暂存区"></a>1.git add file1 file2 file3 file4 把修改过的文件file1234都添加到暂存区</h3><pre><code>git add file1 file2 file3 file4</code></pre><p><img src="https://img-blog.csdnimg.cn/202012101058567.png" alt="提交至暂存区"></p><h3 id="2-git-commit-m-“message”-提交版本至版本库并备注信息message"><a href="#2-git-commit-m-“message”-提交版本至版本库并备注信息message" class="headerlink" title="2.git commit -m “message” 提交版本至版本库并备注信息message"></a>2.git commit -m “message” 提交版本至版本库并备注信息message</h3><pre><code>git commit -m &quot;message&quot;</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210110031339.png" alt="提交版本至本地版本库"></p><h3 id="3-git-log-查看历代版本信息"><a href="#3-git-log-查看历代版本信息" class="headerlink" title="3.git log 查看历代版本信息"></a>3.git log 查看历代版本信息</h3><pre><code>git log</code></pre><p><img src="https://img-blog.csdnimg.cn/2020121011034153.png" alt="查看版本信息"></p><h3 id="4-git-reset-–hard-HEAD-版本回退"><a href="#4-git-reset-–hard-HEAD-版本回退" class="headerlink" title="4.git reset –hard HEAD^ 版本回退"></a>4.git reset –hard HEAD^ 版本回退</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">git reset --hard HEAD^<span class="hljs-regexp">//</span>回退一个版本<br>git reset --hard HEAD^^<span class="hljs-regexp">//</span>回退两个版本<br>git reset --hard HEAD^^^<span class="hljs-regexp">//</span>回退三个版本<br>git reset --hard HEAD～n<span class="hljs-regexp">//</span>回退n个版本<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201210110620198.png" alt="回退一个版本"></p><h3 id="5-git-reset-–hard-5fed7ba-版本选择"><a href="#5-git-reset-–hard-5fed7ba-版本选择" class="headerlink" title="5.git reset –hard 5fed7ba 版本选择"></a>5.git reset –hard 5fed7ba 版本选择</h3><pre><code>//git reset --hard 版本序列号git reset --hard 5fed7ba</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210111154941.png" alt="根据版本序列号选择版本"></p><h3 id="6-git-reflog-查看之前的操作记录，可以看到版本序列号"><a href="#6-git-reflog-查看之前的操作记录，可以看到版本序列号" class="headerlink" title="6.git reflog 查看之前的操作记录，可以看到版本序列号"></a>6.git reflog 查看之前的操作记录，可以看到版本序列号</h3><pre><code>git reflog</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210111416474.png" alt="在这里插入图片描述"></p><h3 id="7-git-status-查看当前的工作区状态，可以看到有哪些文件被修改或增加且尚未提交"><a href="#7-git-status-查看当前的工作区状态，可以看到有哪些文件被修改或增加且尚未提交" class="headerlink" title="7.git status 查看当前的工作区状态，可以看到有哪些文件被修改或增加且尚未提交"></a>7.git status 查看当前的工作区状态，可以看到有哪些文件被修改或增加且尚未提交</h3><pre><code>git status</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210111610664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="查看当前工作区状态再修改文件内容再查看工作区状态"></p><h3 id="8-git-checkout-–-file3-丢弃工作区里文件file3的修改"><a href="#8-git-checkout-–-file3-丢弃工作区里文件file3的修改" class="headerlink" title="8.git checkout – file3 丢弃工作区里文件file3的修改"></a>8.git checkout – file3 丢弃工作区里文件file3的修改</h3><pre><code>git checkout -- file3</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210111814715.png" alt="丢弃工作区file3修改的内容"></p><h3 id="9-git-reset-HEAD-file-取消文件file的暂存"><a href="#9-git-reset-HEAD-file-取消文件file的暂存" class="headerlink" title="9.git reset HEAD file 取消文件file的暂存"></a>9.git reset HEAD file 取消文件file的暂存</h3><pre><code>git reset HEAD file</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210112013297.png" alt="取消暂存区file3的修改"></p><h3 id="10-git-diff-HEAD-–-file-对比工作区和某个版本的某个文件的不同"><a href="#10-git-diff-HEAD-–-file-对比工作区和某个版本的某个文件的不同" class="headerlink" title="10.git diff HEAD – file 对比工作区和某个版本的某个文件的不同"></a>10.git diff HEAD – file 对比工作区和某个版本的某个文件的不同</h3><pre><code>git diff HEAD -- file</code></pre><p>+后面的是工作区中与HEAD版本(当前版本)的不同内容</p><p>-后面是HEAD版本(当前版本)与工作区中的不同内容</p><p><img src="https://img-blog.csdnimg.cn/20201210112214844.png" alt="对比工作区和HEAD版本的文件file3的不同"></p><h3 id="11-git-diff-HEAD-HEAD-–-file-对比两个版本之间的文件file的不同"><a href="#11-git-diff-HEAD-HEAD-–-file-对比两个版本之间的文件file的不同" class="headerlink" title="11.git diff HEAD HEAD^ – file 对比两个版本之间的文件file的不同"></a>11.git diff HEAD HEAD^ – file 对比两个版本之间的文件file的不同</h3><pre><code>git diff HEAD HEAD^ -- file</code></pre><p>HEAD和HEAD^分别为当前版本和上一个版本<br>运行结果里，+后面跟着的是排在前面的版本的不同内容，-后面跟着的是排在后面的版本的不同内容</p><p><img src="https://img-blog.csdnimg.cn/20201210113008597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="对比HEAD和HEAD^版本的文件file3的不同"></p><h3 id="12-git-log-–pretty-oneline-显示简单的版本信息"><a href="#12-git-log-–pretty-oneline-显示简单的版本信息" class="headerlink" title="12.git log –pretty=oneline 显示简单的版本信息"></a>12.git log –pretty=oneline 显示简单的版本信息</h3><pre><code>git log --pretty=oneline</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210113426449.png" alt="显示简单的版本信息"></p><h3 id="13-git-rm-file-–-cached-删除缓存区的文件"><a href="#13-git-rm-file-–-cached-删除缓存区的文件" class="headerlink" title="13.git rm file – cached 删除缓存区的文件"></a>13.git rm file – cached 删除缓存区的文件</h3><pre><code>git rm file -- cached </code></pre><p><img src="https://img-blog.csdnimg.cn/20201210113638537.png" alt="删除缓存区的文件"></p><h2 id="三、分支管理branch"><a href="#三、分支管理branch" class="headerlink" title="三、分支管理branch"></a>三、分支管理branch</h2><h3 id="1-git-branch-查看有几个分支以及当前处于哪个分支"><a href="#1-git-branch-查看有几个分支以及当前处于哪个分支" class="headerlink" title="1.git branch 查看有几个分支以及当前处于哪个分支"></a>1.git branch 查看有几个分支以及当前处于哪个分支</h3><pre><code>git branch</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210113739665.png" alt="查看分支"></p><h3 id="2-git-checkout-b-dev-创建并切换到dev分支里"><a href="#2-git-checkout-b-dev-创建并切换到dev分支里" class="headerlink" title="2.git checkout -b dev 创建并切换到dev分支里"></a>2.git checkout -b dev 创建并切换到dev分支里</h3><pre><code>git checkout -b dev</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210113855953.png" alt="创建并切换到dev分支"></p><h3 id="3-git-checkout-dev-切换到已有分支dev"><a href="#3-git-checkout-dev-切换到已有分支dev" class="headerlink" title="3.git checkout dev 切换到已有分支dev"></a>3.git checkout dev 切换到已有分支dev</h3><pre><code>git checkout dev</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210113943799.png" alt="切换到已有分支master"></p><h3 id="4-git-merge-dev-合并分支，将当前分支和dev分支合并"><a href="#4-git-merge-dev-合并分支，将当前分支和dev分支合并" class="headerlink" title="4.git merge dev 合并分支，将当前分支和dev分支合并"></a>4.git merge dev 合并分支，将当前分支和dev分支合并</h3><pre><code>git merge dev</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210114451346.png" alt="将当前分支和dev分支合并"></p><h3 id="5-git-branch-d-dev-删除分支dev"><a href="#5-git-branch-d-dev-删除分支dev" class="headerlink" title="5.git branch -d dev 删除分支dev"></a>5.git branch -d dev 删除分支dev</h3><pre><code>git branch -d dev</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210114924748.png" alt="删除分支dev"></p><h3 id="6-git-log-–graph-–pretty-oneline-查看带图结构的版本信息"><a href="#6-git-log-–graph-–pretty-oneline-查看带图结构的版本信息" class="headerlink" title="6.git log –graph –pretty=oneline 查看带图结构的版本信息"></a>6.git log –graph –pretty=oneline 查看带图结构的版本信息</h3><pre><code>git log --graph --pretty=oneline</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210114655354.png" alt="查看带图结构的版本信息"></p><h3 id="7-git-merge-–no-ff-m-“message”-dev-禁用快速合并来合并dev分支和当前分支，备注信息为message"><a href="#7-git-merge-–no-ff-m-“message”-dev-禁用快速合并来合并dev分支和当前分支，备注信息为message" class="headerlink" title="7.git merge –no-ff -m “message” dev 禁用快速合并来合并dev分支和当前分支，备注信息为message"></a>7.git merge –no-ff -m “message” dev 禁用快速合并来合并dev分支和当前分支，备注信息为message</h3><pre><code>git merge --no-ff -m &quot;message&quot; dev</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210114845883.png" alt="禁用快速合并来合并dev分支和当前分支"></p><h3 id="8-git-stash-临时保存当前工作区"><a href="#8-git-stash-临时保存当前工作区" class="headerlink" title="8.git stash 临时保存当前工作区"></a>8.git stash 临时保存当前工作区</h3><pre><code>git stash</code></pre><p>比如在工作区进行开发到一半，不能作为一个版本提交，可以用该命令临时保存</p><p><img src="https://img-blog.csdnimg.cn/20201210185615436.png" alt="临时保存当前工作区"></p><h3 id="9-git-stash-pop-恢复临时保存的工作现现场"><a href="#9-git-stash-pop-恢复临时保存的工作现现场" class="headerlink" title="9.git stash pop 恢复临时保存的工作现现场"></a>9.git stash pop 恢复临时保存的工作现现场</h3><pre><code>git stash pop</code></pre><p><img src="https://img-blog.csdnimg.cn/20201210185946806.png" alt="恢复临时保存的工作现现场"></p><h1 id="github远程仓库的团队开发"><a href="#github远程仓库的团队开发" class="headerlink" title="github远程仓库的团队开发"></a>github远程仓库的团队开发</h1><p>前提是安装了ssh服务，并将ssh公钥添加到github上，添加公钥如下图：</p><p><img src="https://img-blog.csdnimg.cn/2020121019235845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="添加公钥"></p><h3 id="1-git-clone-urlforyou-克隆远程仓库到本地仓库"><a href="#1-git-clone-urlforyou-克隆远程仓库到本地仓库" class="headerlink" title="1.git clone urlforyou 克隆远程仓库到本地仓库"></a>1.git clone urlforyou 克隆远程仓库到本地仓库</h3><pre><code>git clone git@github.com:Lixingwei0623/Lixingwei0623.github.io.git</code></pre><p>注意git clone后面跟的是自己要克隆的仓库的地址，查看克隆地址在github或其他远程仓库网站中，如下图。</p><p><img src="https://img-blog.csdnimg.cn/20201210190412172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="克隆的链接"></p><h3 id="2-git-push-origin-dev-推送本地仓库到远程仓库"><a href="#2-git-push-origin-dev-推送本地仓库到远程仓库" class="headerlink" title="2.git push origin dev 推送本地仓库到远程仓库"></a>2.git push origin dev 推送本地仓库到远程仓库</h3><pre><code>git push origin dev</code></pre><p>注意dev是自己要推送的分支之下</p><p><img src="https://img-blog.csdnimg.cn/20201210191205253.png" alt="推送本地仓库到远程仓库"></p><h3 id="3-git-branch-–set-upstream-to-origin-dev-dev-将本地分支跟踪远程分支"><a href="#3-git-branch-–set-upstream-to-origin-dev-dev-将本地分支跟踪远程分支" class="headerlink" title="3.git branch –set-upstream-to=origin/dev dev 将本地分支跟踪远程分支"></a>3.git branch –set-upstream-to=origin/dev dev 将本地分支跟踪远程分支</h3><pre><code>git branch --set-upstream-to=origin/dev dev</code></pre><p>注意前一个dev是远程分支名，后一个为本地分支名</p><h3 id="4-git-pull-origin-dev-从远程仓库拉取代码"><a href="#4-git-pull-origin-dev-从远程仓库拉取代码" class="headerlink" title="4.git pull origin dev 从远程仓库拉取代码"></a>4.git pull origin dev 从远程仓库拉取代码</h3><pre><code>git pull origin dev</code></pre><p>注意dev是远程分支</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>git</category>
      
      <category>命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统（ubuntu）常用命令</title>
    <link href="/Pages/2020/11/30/2020-11-30-Linux%E7%B3%BB%E7%BB%9F%EF%BC%88ubuntu%EF%BC%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4--%E5%88%9D%E5%AD%A6%E7%89%88/"/>
    <url>/Pages/2020/11/30/2020-11-30-Linux%E7%B3%BB%E7%BB%9F%EF%BC%88ubuntu%EF%BC%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4--%E5%88%9D%E5%AD%A6%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>本文所有命令均在ubuntu上正常操作，命令只包括一些常用的快速上手的命令，适合初学者查看。</p><h1 id="一、文件和目录操作"><a href="#一、文件和目录操作" class="headerlink" title="一、文件和目录操作"></a>一、文件和目录操作</h1><h2 id="1-cd-home-进入-home-目录"><a href="#1-cd-home-进入-home-目录" class="headerlink" title="1.cd /home    进入 /home 目录"></a>1.cd /home    进入 /home 目录</h2><pre><code>cd /home</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130112524395.png" alt="在这里插入图片描述"></p><h2 id="2-cd-返回当前目录的上一级目录"><a href="#2-cd-返回当前目录的上一级目录" class="headerlink" title="2.cd ..        返回当前目录的上一级目录"></a>2.cd ..        返回当前目录的上一级目录</h2><pre><code>cd ..</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113146381.png" alt="在这里插入图片描述"></p><h2 id="3-cd-返回当前目录的上两级"><a href="#3-cd-返回当前目录的上两级" class="headerlink" title="3.cd ../..        返回当前目录的上两级"></a>3.cd ../..        返回当前目录的上两级</h2><pre><code>cd ../..</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113154386.png" alt="在这里插入图片描述"></p><h2 id="4-cd-进入当前用户的主目录"><a href="#4-cd-进入当前用户的主目录" class="headerlink" title="4.cd    进入当前用户的主目录"></a>4.cd    进入当前用户的主目录</h2><pre><code>cd</code></pre><p><img src="https://img-blog.csdnimg.cn/2020113011321189.png" alt="在这里插入图片描述"></p><h2 id="5-cd-username-进入username用户的主目录"><a href="#5-cd-username-进入username用户的主目录" class="headerlink" title="5.cd ~username    进入username用户的主目录"></a>5.cd ~username    进入username用户的主目录</h2><pre><code>cd ~username</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113224498.png" alt="在这里插入图片描述"></p><h2 id="6-cd-返回上次所在的目录"><a href="#6-cd-返回上次所在的目录" class="headerlink" title="6.cd -    返回上次所在的目录"></a>6.cd -    返回上次所在的目录</h2><pre><code>cd -</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113235506.png" alt="在这里插入图片描述"></p><h2 id="7-pwd-显示当前工作路径"><a href="#7-pwd-显示当前工作路径" class="headerlink" title="7.pwd        显示当前工作路径"></a>7.pwd        显示当前工作路径</h2><pre><code>pwd</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113242650.png" alt="在这里插入图片描述"></p><h2 id="8-ls-显示当前目录的文件"><a href="#8-ls-显示当前目录的文件" class="headerlink" title="8.ls    显示当前目录的文件"></a>8.ls    显示当前目录的文件</h2><pre><code>ls</code></pre><p><img src="https://img-blog.csdnimg.cn/2020113011325255.png" alt="在这里插入图片描述"></p><h2 id="9-ls-F-显示当前目录的文件"><a href="#9-ls-F-显示当前目录的文件" class="headerlink" title="9.ls -F        显示当前目录的文件"></a>9.ls -F        显示当前目录的文件</h2><pre><code>ls -F</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113301761.png" alt="在这里插入图片描述"></p><h2 id="10-ls-l-显示当前目录下的所有文件及详细信息"><a href="#10-ls-l-显示当前目录下的所有文件及详细信息" class="headerlink" title="10.ls -l        显示当前目录下的所有文件及详细信息"></a>10.ls -l        显示当前目录下的所有文件及详细信息</h2><pre><code>ls -l</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113311147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="11-ls-a-将隐藏文件一同显示出来"><a href="#11-ls-a-将隐藏文件一同显示出来" class="headerlink" title="11.ls -a    将隐藏文件一同显示出来"></a>11.ls -a    将隐藏文件一同显示出来</h2><pre><code>ls -a</code></pre><p><img src="https://img-blog.csdnimg.cn/2020113011333474.png" alt="在这里插入图片描述"></p><h2 id="12-mkdir-dir1-新建一个dir1文件夹"><a href="#12-mkdir-dir1-新建一个dir1文件夹" class="headerlink" title="12.mkdir dir1        新建一个dir1文件夹"></a>12.mkdir dir1        新建一个dir1文件夹</h2><pre><code>mkdir dir1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113345904.png" alt="在这里插入图片描述"></p><h2 id="13-mkdir-dir1-dir2-新建两个文件夹，也可以新建3-4…个"><a href="#13-mkdir-dir1-dir2-新建两个文件夹，也可以新建3-4…个" class="headerlink" title="13.mkdir dir1 dir2        新建两个文件夹，也可以新建3,4…个"></a>13.mkdir dir1 dir2        新建两个文件夹，也可以新建3,4…个</h2><pre><code>mkdir dir1 dir2</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113356733.png" alt="在这里插入图片描述"></p><h2 id="14-rmdir-dir1-删除dir1文件夹"><a href="#14-rmdir-dir1-删除dir1文件夹" class="headerlink" title="14.rmdir dir1        删除dir1文件夹"></a>14.rmdir dir1        删除dir1文件夹</h2><pre><code>rmdir dir1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113405112.png" alt="在这里插入图片描述"></p><h2 id="15-rm-rf-dir1-删除dir1文件夹及其里面的内容"><a href="#15-rm-rf-dir1-删除dir1文件夹及其里面的内容" class="headerlink" title="15.rm -rf dir1        删除dir1文件夹及其里面的内容"></a>15.rm -rf dir1        删除dir1文件夹及其里面的内容</h2><pre><code>rm -rf dir1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113418664.png" alt="在这里插入图片描述"></p><h2 id="16-mv-dir1-new-dir-将dir1移动到new-dir处，并重命名为new-dir"><a href="#16-mv-dir1-new-dir-将dir1移动到new-dir处，并重命名为new-dir" class="headerlink" title="16.mv dir1 new_dir        将dir1移动到new_dir处，并重命名为new_dir"></a>16.mv dir1 new_dir        将dir1移动到new_dir处，并重命名为new_dir</h2><pre><code>mv dir1 new_dir</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113426562.png" alt="在这里插入图片描述"></p><h2 id="17-touch-file-txt-在当前目录新建一个file-txt文件"><a href="#17-touch-file-txt-在当前目录新建一个file-txt文件" class="headerlink" title="17.touch file.txt            在当前目录新建一个file.txt文件"></a>17.touch file.txt            在当前目录新建一个file.txt文件</h2><pre><code>touch file.txt</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113433271.png" alt="在这里插入图片描述"></p><h2 id="18-cp-file-new-file-将file文件复制，然后另存为new-file"><a href="#18-cp-file-new-file-将file文件复制，然后另存为new-file" class="headerlink" title="18.cp file new_file    将file文件复制，然后另存为new_file"></a>18.cp file new_file    将file文件复制，然后另存为new_file</h2><pre><code>cp file new_file</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113442156.png" alt="在这里插入图片描述"></p><h2 id="19-cp-r-dir1-new-dir2-将dir1及其子目录复制并另存为new-dir2"><a href="#19-cp-r-dir1-new-dir2-将dir1及其子目录复制并另存为new-dir2" class="headerlink" title="19.cp -r dir1 new_dir2        将dir1及其子目录复制并另存为new_dir2"></a>19.cp -r dir1 new_dir2        将dir1及其子目录复制并另存为new_dir2</h2><pre><code>    cp -r dir1 new_dir2</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113453758.png" alt="在这里插入图片描述"></p><h2 id="20-ln-s-file1-link1-创建一个指向文件或文件夹-目录-file1的软链接link1，相当于快捷方式"><a href="#20-ln-s-file1-link1-创建一个指向文件或文件夹-目录-file1的软链接link1，相当于快捷方式" class="headerlink" title="20.ln -s file1 link1     创建一个指向文件或文件夹(目录)file1的软链接link1，相当于快捷方式"></a>20.ln -s file1 link1     创建一个指向文件或文件夹(目录)file1的软链接link1，相当于快捷方式</h2><pre><code>ln -s file1 link1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113505448.png" alt="在这里插入图片描述"></p><h2 id="21-ln-file1-link1-创建一个硬链接link1指向file1，注意：不允许将硬链接指向目录"><a href="#21-ln-file1-link1-创建一个硬链接link1指向file1，注意：不允许将硬链接指向目录" class="headerlink" title="21.ln file1 link1        创建一个硬链接link1指向file1，注意：不允许将硬链接指向目录"></a>21.ln file1 link1        创建一个硬链接link1指向file1，注意：不允许将硬链接指向目录</h2><pre><code>ln file1 link1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113512398.png" alt="在这里插入图片描述"></p><h1 id="二、用户和群组操作"><a href="#二、用户和群组操作" class="headerlink" title="二、用户和群组操作"></a>二、用户和群组操作</h1><h2 id="1-addgroup-group-name-创建一个group-name用户组，注意：只有root用户可以创建"><a href="#1-addgroup-group-name-创建一个group-name用户组，注意：只有root用户可以创建" class="headerlink" title="1.addgroup group_name        创建一个group_name用户组，注意：只有root用户可以创建"></a>1.addgroup group_name        创建一个group_name用户组，注意：只有root用户可以创建</h2><pre><code>addgroup group_name</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113529289.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201130113536560.png" alt="在这里插入图片描述"></p><h2 id="2-delgroup-group-name-删除名为group-name的用户组"><a href="#2-delgroup-group-name-删除名为group-name的用户组" class="headerlink" title="2.delgroup group_name        删除名为group_name的用户组"></a>2.delgroup group_name        删除名为group_name的用户组</h2><pre><code>delgroup group_name</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113553956.png" alt="在这里插入图片描述"></p><h2 id="3-groupadd-group-name和groupdel-group-name-效果与1，2大致相同"><a href="#3-groupadd-group-name和groupdel-group-name-效果与1，2大致相同" class="headerlink" title="3.groupadd group_name和groupdel group_name    效果与1，2大致相同"></a>3.groupadd group_name和groupdel group_name    效果与1，2大致相同</h2><pre><code>groupadd group_namegroupdel group_name</code></pre><p><img src="https://img-blog.csdnimg.cn/202011301136050.png" alt="在这里插入图片描述"></p><h2 id="4-useradd-c-“Comments”-g-root-d-home-user1-username-创建一个用户名为username，备注信息为Comments，群组为root，登入目录为-home-user1"><a href="#4-useradd-c-“Comments”-g-root-d-home-user1-username-创建一个用户名为username，备注信息为Comments，群组为root，登入目录为-home-user1" class="headerlink" title="4.useradd -c “Comments” -g root -d /home/user1 username        创建一个用户名为username，备注信息为Comments，群组为root，登入目录为/home/user1"></a>4.useradd -c “Comments” -g root -d /home/user1 username        创建一个用户名为username，备注信息为Comments，群组为root，登入目录为/home/user1</h2><pre><code>useradd -c &quot;Comments&quot; -g root -d /home/user1 username</code></pre><h2 id="5-useradd-username-创建一个用户名为username的用户"><a href="#5-useradd-username-创建一个用户名为username的用户" class="headerlink" title="5.useradd username        创建一个用户名为username的用户"></a>5.useradd username        创建一个用户名为username的用户</h2><pre><code>useradd username</code></pre><h2 id="6-useradd-r-userdir-username-创建一个用户名为username的用户，登入目录为userdir"><a href="#6-useradd-r-userdir-username-创建一个用户名为username的用户，登入目录为userdir" class="headerlink" title="6.useradd -r userdir username    创建一个用户名为username的用户，登入目录为userdir"></a>6.useradd -r userdir username    创建一个用户名为username的用户，登入目录为userdir</h2><pre><code>useradd -r userdir username</code></pre><h2 id="7-userdel-r-userdir-username-删除一个用户名为username的用户，并删除其登入目录userdir"><a href="#7-userdel-r-userdir-username-删除一个用户名为username的用户，并删除其登入目录userdir" class="headerlink" title="7.userdel -r userdir username        删除一个用户名为username的用户，并删除其登入目录userdir"></a>7.userdel -r userdir username        删除一个用户名为username的用户，并删除其登入目录userdir</h2><pre><code>userdel -r userdir username</code></pre><p><img src="https://img-blog.csdnimg.cn/2020113011362390.png" alt="在这里插入图片描述"></p><h2 id="8-usermod-c-“Comments”-g-group-d-home-dir-username-修改username用户的备注为Comments，群组为group，登入目录为-home-dir"><a href="#8-usermod-c-“Comments”-g-group-d-home-dir-username-修改username用户的备注为Comments，群组为group，登入目录为-home-dir" class="headerlink" title="8.usermod -c “Comments” -g group -d /home/dir username        修改username用户的备注为Comments，群组为group，登入目录为/home/dir"></a>8.usermod -c “Comments” -g group -d /home/dir username        修改username用户的备注为Comments，群组为group，登入目录为/home/dir</h2><pre><code>usermod -c “Comments” -g group -d /home/dir username</code></pre><h2 id="9-passwd-修改当前用户密码"><a href="#9-passwd-修改当前用户密码" class="headerlink" title="9.passwd    修改当前用户密码"></a>9.passwd    修改当前用户密码</h2><pre><code>passwd</code></pre><h2 id="10-passwd-user1-修改user1用户的秘密"><a href="#10-passwd-user1-修改user1用户的秘密" class="headerlink" title="10.passwd user1    修改user1用户的秘密"></a>10.passwd user1    修改user1用户的秘密</h2><pre><code>passwd user1</code></pre><h2 id="11-chage-E-2020-12-20-user1-设置用户user1用户密码失效日期"><a href="#11-chage-E-2020-12-20-user1-设置用户user1用户密码失效日期" class="headerlink" title="11.chage -E 2020-12-20 user1        设置用户user1用户密码失效日期"></a>11.chage -E 2020-12-20 user1        设置用户user1用户密码失效日期</h2><pre><code>chage -E 2020-12-20 user1</code></pre><h2 id="12-su-切换root用户，sudo也是一样"><a href="#12-su-切换root用户，sudo也是一样" class="headerlink" title="12.su    切换root用户，sudo也是一样"></a>12.su    切换root用户，sudo也是一样</h2><pre><code>susudo</code></pre><h2 id="13-sudo-i-从当前管理员用户切换到root用户，适合忘记root密码的时候操作"><a href="#13-sudo-i-从当前管理员用户切换到root用户，适合忘记root密码的时候操作" class="headerlink" title="13.sudo -i    从当前管理员用户切换到root用户，适合忘记root密码的时候操作"></a>13.sudo -i    从当前管理员用户切换到root用户，适合忘记root密码的时候操作</h2><pre><code>sudo -i</code></pre><h2 id="14-exit-退出当前用户"><a href="#14-exit-退出当前用户" class="headerlink" title="14.exit    退出当前用户"></a>14.exit    退出当前用户</h2><pre><code>exit</code></pre><h1 id="三、文件的权限操作"><a href="#三、文件的权限操作" class="headerlink" title="三、文件的权限操作"></a>三、文件的权限操作</h1><h2 id="1-ls-lh-显示所有文件以及其权限"><a href="#1-ls-lh-显示所有文件以及其权限" class="headerlink" title="1.ls -lh    显示所有文件以及其权限"></a>1.ls -lh    显示所有文件以及其权限</h2><pre><code>ls -lh</code></pre><p>注：d开头代表文件夹，l开头代表软链接，之后的每一组rwx，分别对应文件所有者、文件所有者群组用户、普通用户的读写执行权限，-代表无该权限，然后第一个用户名是文件所有者，第二个是群组。</p><p><img src="https://img-blog.csdnimg.cn/20201130113701288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-chown-username-file-将file文件的所有者改为username用户"><a href="#2-chown-username-file-将file文件的所有者改为username用户" class="headerlink" title="2.chown username file    将file文件的所有者改为username用户"></a>2.chown username file    将file文件的所有者改为username用户</h2><pre><code>chown username file</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113729214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-chomd-ugo-rwx-dir1-设置目录dir1的所有人-u-、群组-g-以及其他人-o-以读（r-）、写-w-和执行-x-的权限"><a href="#3-chomd-ugo-rwx-dir1-设置目录dir1的所有人-u-、群组-g-以及其他人-o-以读（r-）、写-w-和执行-x-的权限" class="headerlink" title="3.chomd ugo+rwx dir1        设置目录dir1的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限"></a>3.chomd ugo+rwx dir1        设置目录dir1的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</h2><pre><code>chomd u+x dir1    //给所有者(u)以目录dir1的执行(x)权限chomd g+w dir1chomd o+r dir1</code></pre><h2 id="4-chown-user1-group1-file1-改变文件file1的所有人和群组属性为user1和group1"><a href="#4-chown-user1-group1-file1-改变文件file1的所有人和群组属性为user1和group1" class="headerlink" title="4.chown user1:group1 file1  改变文件file1的所有人和群组属性为user1和group1"></a>4.chown user1:group1 file1  改变文件file1的所有人和群组属性为user1和group1</h2><pre><code>chown user1:group1 file1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113740501.png" alt="在这里插入图片描述"></p><h1 id="四、文件搜索"><a href="#四、文件搜索" class="headerlink" title="四、文件搜索"></a>四、文件搜索</h1><h2 id="1-find-name-file1-代表根目录，-name代表按文件名搜索，搜索到名字为file1的文件或目录会显示它的路径"><a href="#1-find-name-file1-代表根目录，-name代表按文件名搜索，搜索到名字为file1的文件或目录会显示它的路径" class="headerlink" title="1.find / -name file1        /代表根目录，-name代表按文件名搜索，搜索到名字为file1的文件或目录会显示它的路径"></a>1.find / -name file1        /代表根目录，-name代表按文件名搜索，搜索到名字为file1的文件或目录会显示它的路径</h2><pre><code>find / -name file1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113755828.png" alt="在这里插入图片描述"></p><h2 id="2-find-user-user1-搜索所有者为user1的文件或目录，显示它们的路径"><a href="#2-find-user-user1-搜索所有者为user1的文件或目录，显示它们的路径" class="headerlink" title="2.find / -user user1        搜索所有者为user1的文件或目录，显示它们的路径"></a>2.find / -user user1        搜索所有者为user1的文件或目录，显示它们的路径</h2><pre><code>find / -user user1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113804128.png" alt="在这里插入图片描述"></p><h2 id="3-find-home-name-txt-在-home路径下搜索以-txt结尾的文件"><a href="#3-find-home-name-txt-在-home路径下搜索以-txt结尾的文件" class="headerlink" title="3.find /home -name *.txt    在/home路径下搜索以.txt结尾的文件"></a>3.find /home -name *.txt    在/home路径下搜索以.txt结尾的文件</h2><pre><code>find /home -name \*.txt</code></pre><p><img src="https://img-blog.csdnimg.cn/20201130113813807.png" alt="在这里插入图片描述"></p><h1 id="五、查看或编辑文件内容"><a href="#五、查看或编辑文件内容" class="headerlink" title="五、查看或编辑文件内容"></a>五、查看或编辑文件内容</h1><h2 id="1-cat-file1-从第一个字节开始正向查看文件file1的内容"><a href="#1-cat-file1-从第一个字节开始正向查看文件file1的内容" class="headerlink" title="1.cat file1    从第一个字节开始正向查看文件file1的内容"></a>1.cat file1    从第一个字节开始正向查看文件file1的内容</h2><pre><code>cat file1</code></pre><h2 id="2-tac-file1-从最后一行开始反向查看文件file1的内容"><a href="#2-tac-file1-从最后一行开始反向查看文件file1的内容" class="headerlink" title="2.tac file1    从最后一行开始反向查看文件file1的内容"></a>2.tac file1    从最后一行开始反向查看文件file1的内容</h2><pre><code>tac file1</code></pre><h2 id="3-head-2-file1-查看文件file1的前两行"><a href="#3-head-2-file1-查看文件file1的前两行" class="headerlink" title="3.head -2 file1    查看文件file1的前两行"></a>3.head -2 file1    查看文件file1的前两行</h2><pre><code>head -2 file1</code></pre><h2 id="4-tail-2-file1-查看文件file1的最后两行"><a href="#4-tail-2-file1-查看文件file1的最后两行" class="headerlink" title="4.tail -2 file1        查看文件file1的最后两行"></a>4.tail -2 file1        查看文件file1的最后两行</h2><pre><code>tail -2 file1</code></pre><h2 id="5-vim-file1-使用vim来编辑文件file1，进入后按i开始编辑，编辑完按esc，然后输入：wq可以保存并退出"><a href="#5-vim-file1-使用vim来编辑文件file1，进入后按i开始编辑，编辑完按esc，然后输入：wq可以保存并退出" class="headerlink" title="5.vim file1        使用vim来编辑文件file1，进入后按i开始编辑，编辑完按esc，然后输入：wq可以保存并退出"></a>5.vim file1        使用vim来编辑文件file1，进入后按i开始编辑，编辑完按esc，然后输入：wq可以保存并退出</h2><pre><code>vim file1</code></pre><h2 id="6-gedit-file1-使用gedit来编辑文件file1，gedit是ubuntu默认的文本编辑器"><a href="#6-gedit-file1-使用gedit来编辑文件file1，gedit是ubuntu默认的文本编辑器" class="headerlink" title="6.gedit file1    使用gedit来编辑文件file1，gedit是ubuntu默认的文本编辑器"></a>6.gedit file1    使用gedit来编辑文件file1，gedit是ubuntu默认的文本编辑器</h2><pre><code>gedit file1</code></pre>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>学习笔记</category>
      
      <category>命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何安装windows和linux双操作系统？</title>
    <link href="/Pages/2020/11/29/2020-11-29-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85windows%E5%92%8Clinux%E5%8F%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F/"/>
    <url>/Pages/2020/11/29/2020-11-29-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85windows%E5%92%8Clinux%E5%8F%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>目标：在已经安装了windows操作系统的情况下，安装一个ubuntu桌面版，以便每次在开机时可以选择要使用的操作系统。</p><h1 id="一、win压缩卷："><a href="#一、win压缩卷：" class="headerlink" title="一、win压缩卷："></a>一、win压缩卷：</h1><p>这一步是从磁盘中分割空间供linux系统使用。</p><h2 id="1-右键此电脑，选择管理，选择磁盘管理。"><a href="#1-右键此电脑，选择管理，选择磁盘管理。" class="headerlink" title="1.右键此电脑，选择管理，选择磁盘管理。"></a>1.右键此电脑，选择管理，选择磁盘管理。</h2><p><img src="https://img-blog.csdnimg.cn/20201129143930349.png" alt="进入磁盘管理"></p><p><img src="https://img-blog.csdnimg.cn/20201129144019117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="磁盘管理界面"></p><h2 id="2-挑选一个磁盘然后右击选择压缩卷，空间大小自己确定。"><a href="#2-挑选一个磁盘然后右击选择压缩卷，空间大小自己确定。" class="headerlink" title="2.挑选一个磁盘然后右击选择压缩卷，空间大小自己确定。"></a>2.挑选一个磁盘然后右击选择压缩卷，空间大小自己确定。</h2><p>注意：至少10G，建议50G及以上。</p><p><img src="https://img-blog.csdnimg.cn/20201129144148283.png" alt="压缩卷"><br><img src="https://img-blog.csdnimg.cn/20201129144809801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="设置压缩卷大小"></p><h1 id="二、下载复刻工具和iso光盘映像文件："><a href="#二、下载复刻工具和iso光盘映像文件：" class="headerlink" title="二、下载复刻工具和iso光盘映像文件："></a>二、下载复刻工具和iso光盘映像文件：</h1><p>我们需要下载的资源包如图：<br>ubuntu-18.04.5-desktop-amd64.iso<br>win32diskimager-1.0.0-install.exe</p><p><img src="https://img-blog.csdnimg.cn/20201129144737237.png" alt="iso文件和刻录工具"></p><h2 id="1-把它们都下载好，然后点击运行刻录工具。"><a href="#1-把它们都下载好，然后点击运行刻录工具。" class="headerlink" title="1.把它们都下载好，然后点击运行刻录工具。"></a>1.把它们都下载好，然后点击运行刻录工具。</h2><p><img src="https://img-blog.csdnimg.cn/20201129145257568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="安装刻录工具"></p><h2 id="2-所有选项都默认，然后点击next就完事。然后到这个界面。"><a href="#2-所有选项都默认，然后点击next就完事。然后到这个界面。" class="headerlink" title="2.所有选项都默认，然后点击next就完事。然后到这个界面。"></a>2.所有选项都默认，然后点击next就完事。然后到这个界面。</h2><p><img src="https://img-blog.csdnimg.cn/20201129145339824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="刻录工具"></p><h2 id="3-选择好映像文件和U盘，开始写入。（注意写入后，U盘所有文件将被覆盖。）"><a href="#3-选择好映像文件和U盘，开始写入。（注意写入后，U盘所有文件将被覆盖。）" class="headerlink" title="3.选择好映像文件和U盘，开始写入。（注意写入后，U盘所有文件将被覆盖。）"></a>3.选择好映像文件和U盘，开始写入。（注意写入后，U盘所有文件将被覆盖。）</h2><h2 id="4-写入完成。"><a href="#4-写入完成。" class="headerlink" title="4.写入完成。"></a>4.写入完成。</h2><h2 id="5-将电脑关机。"><a href="#5-将电脑关机。" class="headerlink" title="5.将电脑关机。"></a>5.将电脑关机。</h2><h1 id="三、开始安装linux系统："><a href="#三、开始安装linux系统：" class="headerlink" title="三、开始安装linux系统："></a>三、开始安装linux系统：</h1><h2 id="1-开机时，持续摁自己电脑机型对应的键来进入BIOS，我的是esc键。"><a href="#1-开机时，持续摁自己电脑机型对应的键来进入BIOS，我的是esc键。" class="headerlink" title="1.开机时，持续摁自己电脑机型对应的键来进入BIOS，我的是esc键。"></a>1.开机时，持续摁自己电脑机型对应的键来进入BIOS，我的是esc键。</h2><p>参考下图可以知道自己该摁哪个键。</p><p><img src="https://img-blog.csdnimg.cn/20201129145541738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="各种型号机器的BIOS键"></p><h2 id="2-选择U盘驱动"><a href="#2-选择U盘驱动" class="headerlink" title="2.选择U盘驱动"></a>2.选择U盘驱动</h2><h2 id="3-点击桌面上Install-Ubnmtu-18-04-5-LTS，出现欢迎界面，可以自己选语言。"><a href="#3-点击桌面上Install-Ubnmtu-18-04-5-LTS，出现欢迎界面，可以自己选语言。" class="headerlink" title="3.点击桌面上Install Ubnmtu 18.04.5 LTS，出现欢迎界面，可以自己选语言。"></a>3.点击桌面上Install Ubnmtu 18.04.5 LTS，出现欢迎界面，可以自己选语言。</h2><p><img src="https://img-blog.csdnimg.cn/20201129145659915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="选择语言"></p><h2 id="4-键盘输入可以如图选：-语言按自己习惯选"><a href="#4-键盘输入可以如图选：-语言按自己习惯选" class="headerlink" title="4.键盘输入可以如图选：(语言按自己习惯选)"></a>4.键盘输入可以如图选：(语言按自己习惯选)</h2><p> <img src="https://img-blog.csdnimg.cn/20201129145720419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="键盘语言"></p><h2 id="5-选正常安装："><a href="#5-选正常安装：" class="headerlink" title="5.选正常安装："></a>5.选正常安装：</h2><p>  <img src="https://img-blog.csdnimg.cn/20201129145759720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="选正常安装"></p><h2 id="6-安装类型："><a href="#6-安装类型：" class="headerlink" title="6.安装类型："></a>6.安装类型：</h2><p><img src="https://img-blog.csdnimg.cn/20201129145816594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="两个系统共存"></p><p>图有点不清楚，不过选第一个，让两个系统共存，就不用后面的分区了。</p><h2 id="7-安装，几分钟后出现如下界面："><a href="#7-安装，几分钟后出现如下界面：" class="headerlink" title="7.安装，几分钟后出现如下界面："></a>7.安装，几分钟后出现如下界面：</h2><p><img src="https://img-blog.csdnimg.cn/20201129145852911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjg5NzEx,size_16,color_FFFFFF,t_70" alt="安装完成"></p><h1 id="四、问题：wifi无法使用，已解决。"><a href="#四、问题：wifi无法使用，已解决。" class="headerlink" title="四、问题：wifi无法使用，已解决。"></a>四、问题：wifi无法使用，已解决。</h1><p>“未发现wifi适配器”。<br>需要联网下载更新驱动，可以通过手机USB共享网络进行下载，可参考博客：<a href="https://my.oschina.net/aomojan/blog/3010779">https://my.oschina.net/aomojan/blog/3010779</a></p>]]></content>
    
    
    <categories>
      
      <category>系统安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双系统</tag>
      
      <tag>linux</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
